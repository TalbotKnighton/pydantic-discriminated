{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pydantic-discriminated","text":"<p>Type-safe discriminated unions for Pydantic models.</p> <p> </p>"},{"location":"#comparison-with-alternatives","title":"Comparison with Alternatives","text":""},{"location":"#why-pydantic-discriminated","title":"Why pydantic-discriminated?","text":"<p>While several libraries offer partial solutions to handling polymorphic data structures, pydantic-discriminated stands out by providing:</p> <ol> <li>True type safety that works with IDEs and static type checkers</li> <li>Seamless integration with Pydantic's ecosystem including FastAPI</li> <li>Flexible configuration with per-call control over serialization behavior</li> <li>Comprehensive support for nested models at any level</li> <li>Simple API with an intuitive decorator-based approach</li> </ol> <p>Most alternatives either lack proper type information, don't support nested structures, or require complex manual configuration. pydantic-discriminated solves these limitations with a clean, type-safe API that feels like a natural extension of Pydantic itself.</p>"},{"location":"#feature-comparison","title":"Feature Comparison","text":"Feature pydantic-discriminated pydantic TaggedUnion python-union pydantic-factories cattrs + attrs marshmallow + marshmallow-oneofschema Type Safety \u2705 Full type-checking support \u26a0\ufe0f Limited \u26a0\ufe0f Partial \u26a0\ufe0f Limited \u26a0\ufe0f Partial \u274c No Nested Models \u2705 Arbitrary nesting levels \u2705 Supported \u274c Limited \u274c No \u26a0\ufe0f Limited \u26a0\ufe0f Limited IDE Support \u2705 Full autocomplete \u26a0\ufe0f Partial \u26a0\ufe0f Partial \u26a0\ufe0f Partial \u26a0\ufe0f Partial \u274c No Runtime Control \u2705 Flexible configuration \u274c No \u274c No \u274c No \u26a0\ufe0f Limited \u26a0\ufe0f Limited OpenAPI Support \u2705 Complete \u2705 Basic \u26a0\ufe0f Manual setup \u274c No \u274c No \u26a0\ufe0f Partial Serialization Control \u2705 Per-call options \u274c No \u274c No \u274c No \u26a0\ufe0f Limited \u26a0\ufe0f Limited Standard Fields \u2705 Configurable \u274c No \u274c No \u274c No \u274c No \u274c No Validation \u2705 Full Pydantic validation \u2705 Full Pydantic validation \u26a0\ufe0f Basic \u26a0\ufe0f Limited \u2705 Supported \u2705 Supported Enum Support \u2705 Native Enum integration \u274c No \u274c No \u274c No \u26a0\ufe0f Manual \u26a0\ufe0f Manual Monkey Patching \u2705 Optional &amp; configurable \u274c No \u274c No \u274c No \u274c No \u274c No FastAPI Integration \u2705 Seamless \u26a0\ufe0f Basic \u26a0\ufe0f Manual setup \u274c No \u274c No \u26a0\ufe0f Limited Learning Curve \u2705 Simple decorator pattern \u26a0\ufe0f Moderate \u26a0\ufe0f Moderate \u26a0\ufe0f Steep \u26a0\ufe0f Steep \u26a0\ufe0f Steep Pydantic v2 Support \u2705 Full support \u2705 Supported \u274c Limited \u26a0\ufe0f Partial \u2753 Unknown \u2753 Unknown"},{"location":"#what-are-discriminated-unions","title":"What are Discriminated Unions?","text":"<p>Discriminated unions (also called tagged unions) let you work with polymorphic data in a type-safe way. A \"discriminator\" field tells you which concrete type you're dealing with.</p> <pre><code>from pydantic_discriminated import discriminated_model, DiscriminatedBaseModel\n\n@discriminated_model(\"shape_type\", \"circle\")\nclass Circle(DiscriminatedBaseModel):\n    radius: float\n\n    def area(self) -&gt; float:\n        return 3.14159 * self.radius ** 2\n\n@discriminated_model(\"shape_type\", \"rectangle\")\nclass Rectangle(DiscriminatedBaseModel):\n    width: float\n    height: float\n\n    def area(self) -&gt; float:\n        return self.width * self.height\n\n# Parse data with the correct type\ndata = {\"shape_type\": \"circle\", \"radius\": 5}\ncircle = Circle.model_validate(data)  # Fully typed as Circle\nprint(f\"Area: {circle.area()}\")  # 78.53975\n</code></pre>"},{"location":"#features","title":"Features","text":"<ul> <li>\ud83d\udd0d Type Safety: Proper type hints for IDE autocomplete and static analysis</li> <li>\ud83d\udce6 Nested Models: Works with models nested at any level</li> <li>\ud83d\udd04 Seamless Integration: Uses standard Pydantic methods (<code>model_validate</code>, <code>model_dump</code>)</li> <li>\ud83e\udde9 Polymorphic Validation: Automatically validates and dispatches to the correct model type</li> <li>\ud83d\udcda OpenAPI Compatible: Works great with FastAPI for generating correct schemas</li> <li>\ud83d\udd27 Flexible Serialization: Control how and when discriminator fields appear in output</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install pydantic-discriminated\n</code></pre>"},{"location":"#how-it-works","title":"How It Works","text":"<p>pydantic-discriminated uses a combination of techniques to provide powerful discriminated union functionality:</p> <ol> <li>Decorator-based Registration: Models are registered with their discriminator field and value</li> <li>Enhanced Serialization: Controls when discriminator fields appear in serialized output</li> <li>Type Preservation: Maintains proper typing for IDE support and static analysis</li> <li>Flexible Configuration: Offers both global and per-model configuration options</li> </ol>"},{"location":"#two-serialization-approaches","title":"Two Serialization Approaches","text":""},{"location":"#1-automatic-simple","title":"1. Automatic (Simple)","text":"<p>With monkey patching enabled (the default), discriminator fields are automatically included:</p> <pre><code>from pydantic import BaseModel\nfrom pydantic_discriminated import discriminated_model, DiscriminatedBaseModel\n\n@discriminated_model(\"shape_type\", \"circle\")\nclass Circle(DiscriminatedBaseModel):\n    radius: float\n\n# Regular BaseModel works automatically\nclass Container(BaseModel):\n    my_shape: Circle\n\ncontainer = Container(my_shape=Circle(radius=5))\ndata = container.model_dump()\n# Includes shape_type automatically:\n# {\"my_shape\": {\"radius\": 5, \"shape_type\": \"circle\", ...}}\n</code></pre>"},{"location":"#2-explicit-advanced","title":"2. Explicit (Advanced)","text":"<p>For more control, you can disable monkey patching and use <code>DiscriminatorAwareBaseModel</code>:</p> <pre><code>from pydantic_discriminated import (\n    discriminated_model, DiscriminatedBaseModel,\n    DiscriminatorAwareBaseModel, DiscriminatedConfig\n)\n\n# Disable automatic patching\nDiscriminatedConfig.disable_monkey_patching()\n\n@discriminated_model(\"shape_type\", \"circle\")\nclass Circle(DiscriminatedBaseModel):\n    radius: float\n\n# Use the aware base model for containers\nclass Container(DiscriminatorAwareBaseModel):\n    my_shape: Circle\n\ncontainer = Container(my_shape=Circle(radius=5))\ndata = container.model_dump()\n# Still includes shape_type:\n# {\"my_shape\": {\"radius\": 5, \"shape_type\": \"circle\", ...}}\n</code></pre>"},{"location":"#quick-example","title":"Quick Example","text":"<p>Define discriminated models for different event types:</p> <pre><code>from enum import Enum\nfrom typing import List, Union\nfrom pydantic import BaseModel\nfrom pydantic_discriminated import discriminated_model, DiscriminatedBaseModel\n\nclass EventType(str, Enum):\n    USER_CREATED = \"user_created\"\n    USER_UPDATED = \"user_updated\"\n    LOGIN_ATTEMPT = \"login_attempt\"\n\n@discriminated_model(EventType, EventType.USER_CREATED)\nclass UserCreatedEvent(DiscriminatedBaseModel):\n    user_id: str\n    username: str\n\n@discriminated_model(EventType, EventType.USER_UPDATED)\nclass UserUpdatedEvent(DiscriminatedBaseModel):\n    user_id: str\n    fields_changed: List[str]\n\n@discriminated_model(EventType, EventType.LOGIN_ATTEMPT)\nclass LoginAttemptEvent(DiscriminatedBaseModel):\n    user_id: str\n    success: bool\n    ip_address: str\n\n# Container that handles any event type\nclass EventProcessor(BaseModel):\n    events: List[Union[UserCreatedEvent, UserUpdatedEvent, LoginAttemptEvent]]\n\n    def process(self):\n        for event in self.events:\n            if isinstance(event, UserCreatedEvent):\n                print(f\"New user created: {event.username}\")\n            elif isinstance(event, UserUpdatedEvent):\n                print(f\"User {event.user_id} updated fields: {event.fields_changed}\")\n            elif isinstance(event, LoginAttemptEvent):\n                result = \"succeeded\" if event.success else \"failed\"\n                print(f\"Login {result} for user {event.user_id} from {event.ip_address}\")\n</code></pre>"},{"location":"#fine-grained-control","title":"Fine-Grained Control","text":"<p>You can control discriminator field inclusion on a per-call basis:</p> <pre><code># Always include discriminator fields (with monkey patching enabled)\ndata = shape.model_dump()\n\n# Explicitly control discriminator inclusion\nwith_disc = shape.model_dump(use_discriminators=True)\nwithout_disc = shape.model_dump(use_discriminators=False)\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Full Documentation</li> <li>API Reference</li> <li>Examples</li> </ul>"},{"location":"#when-to-use","title":"When To Use","text":"<p>This library is perfect for:</p> <ul> <li>API Responses: When endpoints return different object types</li> <li>Event Systems: Handling different event types in a type-safe way</li> <li>State Machines: Representing different states with specific properties</li> <li>Polymorphic Data: Working with heterogeneous data structures</li> </ul>"},{"location":"#resources","title":"Resources","text":"<ul> <li>GitHub Repository</li> <li>PyPI Package</li> <li>Issue Tracker</li> </ul>"},{"location":"#license","title":"License","text":"<p>MIT</p> <p>Built by Talbot Knighton</p>"},{"location":"technical_documentation/","title":"Technical Implementation","text":"<p>This page explains the technical details of how pydantic-discriminated works under the hood.</p>"},{"location":"technical_documentation/#architecture-overview","title":"Architecture Overview","text":"<p>pydantic-discriminated consists of several key components:</p> <ol> <li>DiscriminatedBaseModel: Base class for all discriminated models</li> <li>DiscriminatorAwareBaseModel: Base class for containers that need to handle discriminated models</li> <li>DiscriminatedModelRegistry: Central registry of discriminated models and their values</li> <li>DiscriminatedConfig: Global configuration settings</li> <li>Monkey Patching System: Optional enhancement to Pydantic's BaseModel for automatic discriminator handling</li> </ol>"},{"location":"technical_documentation/#discriminator-registration","title":"Discriminator Registration","text":"<p>The <code>@discriminated_model</code> decorator performs several important tasks:</p> <ol> <li>Registers the model class in the <code>DiscriminatedModelRegistry</code> with its category and value</li> <li>Sets class-level attributes (<code>_discriminator_field</code>, <code>_discriminator_value</code>) to store discriminator information</li> <li>Adds the discriminator field to the model's annotations</li> <li>Overrides <code>__init__</code> to ensure discriminator values are set on the instance</li> </ol> <pre><code>@discriminated_model(\"animal_type\", \"dog\")\nclass Dog(DiscriminatedBaseModel):\n    name: str\n    breed: str\n</code></pre> <p>This registration enables: - Type-safe validation (ensuring the discriminator field has the correct value) - Runtime access to discriminator information - Proper serialization of discriminator fields</p>"},{"location":"technical_documentation/#serialization-strategies","title":"Serialization Strategies","text":""},{"location":"technical_documentation/#1-monkey-patching-approach","title":"1. Monkey Patching Approach","text":"<p>When enabled, this approach patches Pydantic's <code>BaseModel.model_dump</code> and <code>BaseModel.model_dump_json</code> methods to automatically process discriminator fields in nested models.</p> <p>The patching process: 1. Stores the original methods in <code>_original_methods</code> 2. Defines patched versions that check the <code>use_discriminators</code> parameter or global setting 3. Processes nested models to add discriminator fields when appropriate</p> <p>This approach allows regular <code>BaseModel</code> containers to automatically handle discriminated models.</p>"},{"location":"technical_documentation/#2-explicit-base-class-approach","title":"2. Explicit Base Class Approach","text":"<p>For more control or when monkey patching is disabled, <code>DiscriminatorAwareBaseModel</code> provides explicit handling of discriminated fields:</p> <ul> <li>Overrides <code>model_dump</code> and <code>model_dump_json</code> to always process discriminators</li> <li>Recursively processes nested models to ensure consistent behavior</li> <li>Not affected by the global monkey patching setting</li> </ul>"},{"location":"technical_documentation/#discriminator-processing","title":"Discriminator Processing","text":"<p>The <code>_process_discriminators</code> function is responsible for:</p> <ol> <li>Recursively traversing the serialized data structure</li> <li>Identifying discriminated models at any nesting level</li> <li>Adding or removing discriminator fields based on configuration</li> <li>Handling lists of models, individual models, and regular fields appropriately</li> </ol>"},{"location":"technical_documentation/#standard-fields","title":"Standard Fields","text":"<p>For interoperability with different systems, pydantic-discriminated supports standard discriminator fields:</p> <ul> <li>Domain-specific field: The field name used in your domain model (e.g., <code>\"shape_type\"</code>)</li> <li>Standard category field: Always <code>\"discriminator_category\"</code>, stores the field name</li> <li>Standard value field: Always <code>\"discriminator_value\"</code>, stores the discriminator value</li> </ul> <p>This allows other systems to identify and process discriminated models without prior knowledge of your domain-specific fields.</p>"},{"location":"technical_documentation/#configuration-options","title":"Configuration Options","text":"<p>The <code>DiscriminatedConfig</code> class provides global settings:</p> <ul> <li>use_standard_fields: Whether to include standard discriminator fields</li> <li>standard_category_field: Name of the standard category field</li> <li>standard_value_field: Name of the standard value field</li> <li>patch_base_model: Whether to apply monkey patching to BaseModel</li> </ul> <p>These can be overridden: 1. Globally via <code>DiscriminatedConfig</code> 2. Per-model via <code>model_config</code> 3. Per-decorator via parameters 4. Per-call via <code>use_discriminators</code> parameter</p>"},{"location":"technical_documentation/#performance-considerations","title":"Performance Considerations","text":"<p>The library is designed for efficiency:</p> <ul> <li>Registry lookups are O(1)</li> <li>Serialization processing adds minimal overhead</li> <li>Type information is preserved without runtime cost</li> <li>Monkey patching is applied only once regardless of imports</li> </ul>"},{"location":"technical_documentation/#implementation-challenges","title":"Implementation Challenges","text":"<p>Some interesting challenges addressed in the implementation:</p> <ol> <li>Preserving Type Safety: Ensuring IDEs and type checkers understand discriminated unions</li> <li>Recursive Processing: Handling models nested at arbitrary depths</li> <li>Configuration Flexibility: Balancing global settings with per-model and per-call options</li> <li>Monkey Patching Control: Providing both automatic and explicit approaches</li> <li>Discriminator Validation: Ensuring discriminator values match at validation time</li> </ol>"},{"location":"technical_documentation/#extending-the-library","title":"Extending the Library","text":"<p>To extend the library, you can:</p> <ol> <li>Create custom base classes that inherit from <code>DiscriminatedBaseModel</code></li> <li>Add middleware to process discriminator fields in specific ways</li> <li>Implement custom serializers for special discriminator handling</li> <li>Extend <code>DiscriminatedConfig</code> with additional settings</li> </ol>"},{"location":"technical_documentation/#integration-with-other-libraries","title":"Integration with Other Libraries","text":"<p>pydantic-discriminated is designed to work seamlessly with:</p> <ul> <li>FastAPI: For generating correct OpenAPI schemas with discriminators</li> <li>SQLModel: For ORM models that need discriminator functionality</li> <li>Type checkers: mypy, pyright, etc.</li> <li>API clients: For properly serializing discriminated models in requests</li> </ul>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>pydantic_discriminated<ul> <li>api</li> </ul> </li> </ul>"},{"location":"reference/pydantic_discriminated/","title":"pydantic_discriminated","text":"<p>pydantic-discriminated: Type-safe discriminated unions for Pydantic models.</p>"},{"location":"reference/pydantic_discriminated/#pydantic_discriminated.DiscriminatedBaseModel","title":"<code>DiscriminatedBaseModel</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base class for discriminated models that ensures discriminator fields are included in serialization only when requested.</p> <p>This class must be used as the base class for all models that will be part of a discriminated union. It provides methods for validating and serializing discriminated models.</p> <p>Attributes:</p> Name Type Description <code>_discriminator_field</code> <code>ClassVar[str]</code> <p>The discriminator field name.</p> <code>_discriminator_value</code> <code>ClassVar[Any]</code> <p>The discriminator value for this model.</p> <code>_use_standard_fields</code> <code>ClassVar[bool]</code> <p>Whether to use standard discriminator fields. Defaults to the global setting in DiscriminatedConfig.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; @discriminated_model(\"shape_type\", \"circle\")\n... class Circle(DiscriminatedBaseModel):\n...     radius: float\n&gt;&gt;&gt; circle = Circle(radius=5)\n&gt;&gt;&gt; data = circle.model_dump()  # Includes discriminator fields\n</code></pre> Source code in <code>src/pydantic_discriminated/api.py</code> <pre><code>class DiscriminatedBaseModel(BaseModel):\n    \"\"\"\n    Base class for discriminated models that ensures discriminator fields are included\n    in serialization only when requested.\n\n    This class must be used as the base class for all models that will be part of\n    a discriminated union. It provides methods for validating and serializing\n    discriminated models.\n\n    Attributes:\n        _discriminator_field (ClassVar[str]): The discriminator field name.\n        _discriminator_value (ClassVar[Any]): The discriminator value for this model.\n        _use_standard_fields (ClassVar[bool]): Whether to use standard discriminator fields.\n            Defaults to the global setting in DiscriminatedConfig.\n\n    Examples:\n        &gt;&gt;&gt; @discriminated_model(\"shape_type\", \"circle\")\n        ... class Circle(DiscriminatedBaseModel):\n        ...     radius: float\n        &gt;&gt;&gt; circle = Circle(radius=5)\n        &gt;&gt;&gt; data = circle.model_dump()  # Includes discriminator fields\n    \"\"\"\n\n    # Legacy fields for compatibility\n    _discriminator_field: ClassVar[str] = \"\"\n    _discriminator_value: ClassVar[Any] = None\n    _use_standard_fields: ClassVar[bool] = DiscriminatedConfig.use_standard_fields\n\n    def __getattr__(self, name: str) -&gt; Any:\n        \"\"\"\n        Custom attribute access to handle discriminator field.\n\n        This method allows accessing the discriminator value through the discriminator\n        field name, as well as through the standard discriminator fields.\n\n        Args:\n            name (str): The attribute name being accessed.\n\n        Returns:\n            (Any): The discriminator value if name is the discriminator field or a standard\n            discriminator field, otherwise raises AttributeError.\n\n        Raises:\n            (AttributeError): If the attribute doesn't exist and isn't a discriminator field.\n        \"\"\"\n        # Handle access to the legacy discriminator field\n        if name == self._discriminator_field:\n            return self._discriminator_value\n\n        # Handle access to standard discriminator fields\n        if name == DiscriminatedConfig.standard_category_field:\n            return self._discriminator_field\n        if name == DiscriminatedConfig.standard_value_field:\n            return self._discriminator_value\n\n        # Default behavior for other attributes\n        return super().__getattr__(name)\n\n    def model_dump(self, **kwargs: Any):\n        \"\"\"\n        Override model_dump to control when discriminators are included.\n\n        This method allows controlling whether discriminator fields are included\n        in the serialized output using the use_discriminators parameter or the\n        global setting.\n\n        Args:\n            **kwargs: Keyword arguments to pass to the parent model_dump method.\n                A special 'use_discriminators' parameter can be passed to override\n                the global setting.\n\n        Returns:\n            (dict): The serialized model with discriminator fields included or excluded\n                based on configuration.\n        \"\"\"\n        # Extract our custom parameter or use the global setting\n        use_discriminators = kwargs.pop(\"use_discriminators\", DiscriminatedConfig.patch_base_model)\n        print(f\"DEBUG DiscriminatedBaseModel.model_dump: use_discriminators={use_discriminators}\")\n\n        # Get the result from the original method (without our custom parameter)\n        if DiscriminatedConfig._patched:\n            # If patched, use the original method via the global store\n            # Make a copy of kwargs to avoid modifying the original\n            kwargs_copy = kwargs.copy()\n            if \"use_discriminators\" in kwargs_copy:\n                del kwargs_copy[\"use_discriminators\"]\n            data = _original_methods[\"model_dump\"](self, **kwargs_copy)\n        else:\n            # If not patched, use the superclass method\n            data = super().model_dump(**kwargs)\n\n        # Remove discriminator fields if they shouldn't be included\n        if not use_discriminators:\n            # Remove domain-specific discriminator field\n            if self._discriminator_field in data:\n                data.pop(self._discriminator_field)\n\n            # Remove standard fields if present\n            if self._use_standard_fields:\n                if DiscriminatedConfig.standard_category_field in data:\n                    data.pop(DiscriminatedConfig.standard_category_field)\n                if DiscriminatedConfig.standard_value_field in data:\n                    data.pop(DiscriminatedConfig.standard_value_field)\n\n        return data\n\n    @model_serializer\n    def serialize_model(self) -&gt; Dict[str, Any]:\n        \"\"\"\n        Custom serializer that includes discriminator fields only when requested.\n\n        This method is used by Pydantic's serialization system to convert the model\n        to a dictionary. It includes the discriminator fields, which can later be\n        filtered out by model_dump if needed.\n\n        Returns:\n            (dict): Dictionary representation of the model, including discriminator fields.\n        \"\"\"\n        # Get all field values without special handling\n        data = {k: v for k, v in self.__dict__.items() if not k.startswith(\"_\")}\n\n        # Add discriminator fields if configured to do so in global settings\n        # These will be filtered in model_dump if needed\n        if self._discriminator_field and self._discriminator_value is not None:\n            data[self._discriminator_field] = self._discriminator_value\n\n        # Add standard fields if configured\n        if self._use_standard_fields:\n            data[DiscriminatedConfig.standard_category_field] = self._discriminator_field\n            data[DiscriminatedConfig.standard_value_field] = self._discriminator_value\n\n        return data\n\n    @classmethod\n    def model_validate(cls: Type[T], obj: Any, **kwargs: Any) -&gt; T:\n        \"\"\"\n        Validate the given object and return an instance of this model.\n\n        Enhanced to handle discriminator validation. This method checks if the\n        discriminator value in the input data matches the expected value for this\n        model class.\n\n        Args:\n            obj: The object to validate.\n            **kwargs: Additional arguments to pass to the original model_validate.\n\n        Returns:\n            An instance of this model.\n\n        Raises:\n            ValueError: If the discriminator value in the input data doesn't match\n                the expected value for this model class.\n\n        Examples:\n            &gt;&gt;&gt; data = {\"shape_type\": \"circle\", \"radius\": 5}\n            &gt;&gt;&gt; circle = Circle.model_validate(data)\n        \"\"\"\n        use_standard_fields = getattr(\n            cls, \"_use_standard_fields\", DiscriminatedConfig.use_standard_fields\n        )\n\n        if isinstance(obj, dict):\n            new_obj = obj.copy()  # Create a copy to avoid modifying the original\n\n            # Check if we have standard discriminator fields\n            if (\n                use_standard_fields\n                and DiscriminatedConfig.standard_category_field in new_obj\n                and DiscriminatedConfig.standard_value_field in new_obj\n            ):\n\n                # Use standard fields for validation\n                if new_obj[DiscriminatedConfig.standard_category_field] != cls._discriminator_field:\n                    raise ValueError(\n                        f\"Invalid discriminator category: expected {cls._discriminator_field}, \"\n                        f\"got {new_obj[DiscriminatedConfig.standard_category_field]}\"\n                    )\n                if new_obj[DiscriminatedConfig.standard_value_field] != cls._discriminator_value:\n                    raise ValueError(\n                        f\"Invalid discriminator value: expected {cls._discriminator_value}, \"\n                        f\"got {new_obj[DiscriminatedConfig.standard_value_field]}\"\n                    )\n\n            # Check legacy field if present\n            elif cls._discriminator_field and cls._discriminator_field in new_obj:\n                if new_obj[cls._discriminator_field] != cls._discriminator_value:\n                    raise ValueError(\n                        f\"Invalid discriminator value: expected {cls._discriminator_value}, \"\n                        f\"got {new_obj[cls._discriminator_field]}\"\n                    )\n\n            # Add domain-specific discriminator field if missing\n            if cls._discriminator_field and cls._discriminator_field not in new_obj:\n                new_obj[cls._discriminator_field] = cls._discriminator_value\n\n            # Add standard discriminator fields if configured and missing\n            if use_standard_fields:\n                if DiscriminatedConfig.standard_category_field not in new_obj:\n                    new_obj[DiscriminatedConfig.standard_category_field] = cls._discriminator_field\n                if DiscriminatedConfig.standard_value_field not in new_obj:\n                    new_obj[DiscriminatedConfig.standard_value_field] = cls._discriminator_value\n\n            obj = new_obj\n\n        # Call the original model_validate\n        instance = super().model_validate(obj, **kwargs)\n\n        # Set the discriminator values on the instance\n        object.__setattr__(instance, \"_discriminator_field\", cls._discriminator_field)\n        object.__setattr__(instance, \"_discriminator_value\", cls._discriminator_value)\n        object.__setattr__(instance, \"_use_standard_fields\", use_standard_fields)\n\n        # For backward compatibility, also set the domain-specific field\n        if cls._discriminator_field:\n            object.__setattr__(instance, cls._discriminator_field, cls._discriminator_value)\n\n        # Set standard fields if configured\n        if use_standard_fields:\n            object.__setattr__(\n                instance,\n                DiscriminatedConfig.standard_category_field,\n                cls._discriminator_field,\n            )\n            object.__setattr__(\n                instance,\n                DiscriminatedConfig.standard_value_field,\n                cls._discriminator_value,\n            )\n\n        return instance\n\n    @classmethod\n    def model_validate_json(cls: Type[T], json_data: Union[str, bytes], **kwargs: Any) -&gt; T:\n        \"\"\"\n        Validate the given JSON data and return an instance of this model.\n\n        Enhanced to handle discriminator validation. This method parses the JSON data\n        and then uses model_validate to validate it.\n\n        Args:\n            json_data: The JSON data to validate.\n            **kwargs: Additional arguments to pass to model_validate.\n\n        Returns:\n            An instance of this model.\n\n        Examples:\n            &gt;&gt;&gt; json_str = '{\"shape_type\": \"circle\", \"radius\": 5}'\n            &gt;&gt;&gt; circle = Circle.model_validate_json(json_str)\n        \"\"\"\n        # Parse JSON first\n        if isinstance(json_data, bytes):\n            json_data = json_data.decode()\n        data = json.loads(json_data)\n\n        # Now validate with our enhanced model_validate\n        return cls.model_validate(data, **kwargs)\n\n    @classmethod\n    def validate_discriminated(cls, data: Dict[str, Any]) -&gt; \"DiscriminatedBaseModel\":\n        \"\"\"\n        Validate and return the appropriate discriminated model based on the discriminator value.\n\n        This method looks at the discriminator fields in the data and dispatches\n        to the appropriate model class based on the discriminator value.\n\n        Args:\n            data: The data to validate.\n\n        Returns:\n            An instance of the appropriate discriminated model.\n\n        Raises:\n            ValueError: If no discriminator fields are found in the data.\n\n        Examples:\n            &gt;&gt;&gt; data = {\"shape_type\": \"circle\", \"radius\": 5}\n            &gt;&gt;&gt; shape = DiscriminatedBaseModel.validate_discriminated(data)\n            &gt;&gt;&gt; isinstance(shape, Circle)\n            True\n        \"\"\"\n        use_standard_fields = getattr(\n            cls, \"_use_standard_fields\", DiscriminatedConfig.use_standard_fields\n        )\n\n        # First check standard discriminator fields if configured\n        if (\n            use_standard_fields\n            and DiscriminatedConfig.standard_category_field in data\n            and DiscriminatedConfig.standard_value_field in data\n        ):\n\n            category = data[DiscriminatedConfig.standard_category_field]\n            value = data[DiscriminatedConfig.standard_value_field]\n\n        # Fall back to domain-specific field\n        elif cls._discriminator_field and cls._discriminator_field in data:\n            category = cls._discriminator_field\n            value = data[cls._discriminator_field]\n        else:\n            raise ValueError(f\"No discriminator fields found in data\")\n\n        # Get the appropriate model class\n        model_cls = DiscriminatedModelRegistry.get_model(category, value)\n\n        # Validate with the model class\n        return model_cls.model_validate(data)\n</code></pre>"},{"location":"reference/pydantic_discriminated/#pydantic_discriminated.DiscriminatedBaseModel.__getattr__","title":"<code>__getattr__(name)</code>","text":"<p>Custom attribute access to handle discriminator field.</p> <p>This method allows accessing the discriminator value through the discriminator field name, as well as through the standard discriminator fields.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The attribute name being accessed.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The discriminator value if name is the discriminator field or a standard</p> <code>Any</code> <p>discriminator field, otherwise raises AttributeError.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If the attribute doesn't exist and isn't a discriminator field.</p> Source code in <code>src/pydantic_discriminated/api.py</code> <pre><code>def __getattr__(self, name: str) -&gt; Any:\n    \"\"\"\n    Custom attribute access to handle discriminator field.\n\n    This method allows accessing the discriminator value through the discriminator\n    field name, as well as through the standard discriminator fields.\n\n    Args:\n        name (str): The attribute name being accessed.\n\n    Returns:\n        (Any): The discriminator value if name is the discriminator field or a standard\n        discriminator field, otherwise raises AttributeError.\n\n    Raises:\n        (AttributeError): If the attribute doesn't exist and isn't a discriminator field.\n    \"\"\"\n    # Handle access to the legacy discriminator field\n    if name == self._discriminator_field:\n        return self._discriminator_value\n\n    # Handle access to standard discriminator fields\n    if name == DiscriminatedConfig.standard_category_field:\n        return self._discriminator_field\n    if name == DiscriminatedConfig.standard_value_field:\n        return self._discriminator_value\n\n    # Default behavior for other attributes\n    return super().__getattr__(name)\n</code></pre>"},{"location":"reference/pydantic_discriminated/#pydantic_discriminated.DiscriminatedBaseModel.model_dump","title":"<code>model_dump(**kwargs)</code>","text":"<p>Override model_dump to control when discriminators are included.</p> <p>This method allows controlling whether discriminator fields are included in the serialized output using the use_discriminators parameter or the global setting.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Keyword arguments to pass to the parent model_dump method. A special 'use_discriminators' parameter can be passed to override the global setting.</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict</code> <p>The serialized model with discriminator fields included or excluded based on configuration.</p> Source code in <code>src/pydantic_discriminated/api.py</code> <pre><code>def model_dump(self, **kwargs: Any):\n    \"\"\"\n    Override model_dump to control when discriminators are included.\n\n    This method allows controlling whether discriminator fields are included\n    in the serialized output using the use_discriminators parameter or the\n    global setting.\n\n    Args:\n        **kwargs: Keyword arguments to pass to the parent model_dump method.\n            A special 'use_discriminators' parameter can be passed to override\n            the global setting.\n\n    Returns:\n        (dict): The serialized model with discriminator fields included or excluded\n            based on configuration.\n    \"\"\"\n    # Extract our custom parameter or use the global setting\n    use_discriminators = kwargs.pop(\"use_discriminators\", DiscriminatedConfig.patch_base_model)\n    print(f\"DEBUG DiscriminatedBaseModel.model_dump: use_discriminators={use_discriminators}\")\n\n    # Get the result from the original method (without our custom parameter)\n    if DiscriminatedConfig._patched:\n        # If patched, use the original method via the global store\n        # Make a copy of kwargs to avoid modifying the original\n        kwargs_copy = kwargs.copy()\n        if \"use_discriminators\" in kwargs_copy:\n            del kwargs_copy[\"use_discriminators\"]\n        data = _original_methods[\"model_dump\"](self, **kwargs_copy)\n    else:\n        # If not patched, use the superclass method\n        data = super().model_dump(**kwargs)\n\n    # Remove discriminator fields if they shouldn't be included\n    if not use_discriminators:\n        # Remove domain-specific discriminator field\n        if self._discriminator_field in data:\n            data.pop(self._discriminator_field)\n\n        # Remove standard fields if present\n        if self._use_standard_fields:\n            if DiscriminatedConfig.standard_category_field in data:\n                data.pop(DiscriminatedConfig.standard_category_field)\n            if DiscriminatedConfig.standard_value_field in data:\n                data.pop(DiscriminatedConfig.standard_value_field)\n\n    return data\n</code></pre>"},{"location":"reference/pydantic_discriminated/#pydantic_discriminated.DiscriminatedBaseModel.model_validate","title":"<code>model_validate(obj, **kwargs)</code>  <code>classmethod</code>","text":"<p>Validate the given object and return an instance of this model.</p> <p>Enhanced to handle discriminator validation. This method checks if the discriminator value in the input data matches the expected value for this model class.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>The object to validate.</p> required <code>**kwargs</code> <code>Any</code> <p>Additional arguments to pass to the original model_validate.</p> <code>{}</code> <p>Returns:</p> Type Description <code>T</code> <p>An instance of this model.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the discriminator value in the input data doesn't match the expected value for this model class.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; data = {\"shape_type\": \"circle\", \"radius\": 5}\n&gt;&gt;&gt; circle = Circle.model_validate(data)\n</code></pre> Source code in <code>src/pydantic_discriminated/api.py</code> <pre><code>@classmethod\ndef model_validate(cls: Type[T], obj: Any, **kwargs: Any) -&gt; T:\n    \"\"\"\n    Validate the given object and return an instance of this model.\n\n    Enhanced to handle discriminator validation. This method checks if the\n    discriminator value in the input data matches the expected value for this\n    model class.\n\n    Args:\n        obj: The object to validate.\n        **kwargs: Additional arguments to pass to the original model_validate.\n\n    Returns:\n        An instance of this model.\n\n    Raises:\n        ValueError: If the discriminator value in the input data doesn't match\n            the expected value for this model class.\n\n    Examples:\n        &gt;&gt;&gt; data = {\"shape_type\": \"circle\", \"radius\": 5}\n        &gt;&gt;&gt; circle = Circle.model_validate(data)\n    \"\"\"\n    use_standard_fields = getattr(\n        cls, \"_use_standard_fields\", DiscriminatedConfig.use_standard_fields\n    )\n\n    if isinstance(obj, dict):\n        new_obj = obj.copy()  # Create a copy to avoid modifying the original\n\n        # Check if we have standard discriminator fields\n        if (\n            use_standard_fields\n            and DiscriminatedConfig.standard_category_field in new_obj\n            and DiscriminatedConfig.standard_value_field in new_obj\n        ):\n\n            # Use standard fields for validation\n            if new_obj[DiscriminatedConfig.standard_category_field] != cls._discriminator_field:\n                raise ValueError(\n                    f\"Invalid discriminator category: expected {cls._discriminator_field}, \"\n                    f\"got {new_obj[DiscriminatedConfig.standard_category_field]}\"\n                )\n            if new_obj[DiscriminatedConfig.standard_value_field] != cls._discriminator_value:\n                raise ValueError(\n                    f\"Invalid discriminator value: expected {cls._discriminator_value}, \"\n                    f\"got {new_obj[DiscriminatedConfig.standard_value_field]}\"\n                )\n\n        # Check legacy field if present\n        elif cls._discriminator_field and cls._discriminator_field in new_obj:\n            if new_obj[cls._discriminator_field] != cls._discriminator_value:\n                raise ValueError(\n                    f\"Invalid discriminator value: expected {cls._discriminator_value}, \"\n                    f\"got {new_obj[cls._discriminator_field]}\"\n                )\n\n        # Add domain-specific discriminator field if missing\n        if cls._discriminator_field and cls._discriminator_field not in new_obj:\n            new_obj[cls._discriminator_field] = cls._discriminator_value\n\n        # Add standard discriminator fields if configured and missing\n        if use_standard_fields:\n            if DiscriminatedConfig.standard_category_field not in new_obj:\n                new_obj[DiscriminatedConfig.standard_category_field] = cls._discriminator_field\n            if DiscriminatedConfig.standard_value_field not in new_obj:\n                new_obj[DiscriminatedConfig.standard_value_field] = cls._discriminator_value\n\n        obj = new_obj\n\n    # Call the original model_validate\n    instance = super().model_validate(obj, **kwargs)\n\n    # Set the discriminator values on the instance\n    object.__setattr__(instance, \"_discriminator_field\", cls._discriminator_field)\n    object.__setattr__(instance, \"_discriminator_value\", cls._discriminator_value)\n    object.__setattr__(instance, \"_use_standard_fields\", use_standard_fields)\n\n    # For backward compatibility, also set the domain-specific field\n    if cls._discriminator_field:\n        object.__setattr__(instance, cls._discriminator_field, cls._discriminator_value)\n\n    # Set standard fields if configured\n    if use_standard_fields:\n        object.__setattr__(\n            instance,\n            DiscriminatedConfig.standard_category_field,\n            cls._discriminator_field,\n        )\n        object.__setattr__(\n            instance,\n            DiscriminatedConfig.standard_value_field,\n            cls._discriminator_value,\n        )\n\n    return instance\n</code></pre>"},{"location":"reference/pydantic_discriminated/#pydantic_discriminated.DiscriminatedBaseModel.model_validate_json","title":"<code>model_validate_json(json_data, **kwargs)</code>  <code>classmethod</code>","text":"<p>Validate the given JSON data and return an instance of this model.</p> <p>Enhanced to handle discriminator validation. This method parses the JSON data and then uses model_validate to validate it.</p> <p>Parameters:</p> Name Type Description Default <code>json_data</code> <code>Union[str, bytes]</code> <p>The JSON data to validate.</p> required <code>**kwargs</code> <code>Any</code> <p>Additional arguments to pass to model_validate.</p> <code>{}</code> <p>Returns:</p> Type Description <code>T</code> <p>An instance of this model.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; json_str = '{\"shape_type\": \"circle\", \"radius\": 5}'\n&gt;&gt;&gt; circle = Circle.model_validate_json(json_str)\n</code></pre> Source code in <code>src/pydantic_discriminated/api.py</code> <pre><code>@classmethod\ndef model_validate_json(cls: Type[T], json_data: Union[str, bytes], **kwargs: Any) -&gt; T:\n    \"\"\"\n    Validate the given JSON data and return an instance of this model.\n\n    Enhanced to handle discriminator validation. This method parses the JSON data\n    and then uses model_validate to validate it.\n\n    Args:\n        json_data: The JSON data to validate.\n        **kwargs: Additional arguments to pass to model_validate.\n\n    Returns:\n        An instance of this model.\n\n    Examples:\n        &gt;&gt;&gt; json_str = '{\"shape_type\": \"circle\", \"radius\": 5}'\n        &gt;&gt;&gt; circle = Circle.model_validate_json(json_str)\n    \"\"\"\n    # Parse JSON first\n    if isinstance(json_data, bytes):\n        json_data = json_data.decode()\n    data = json.loads(json_data)\n\n    # Now validate with our enhanced model_validate\n    return cls.model_validate(data, **kwargs)\n</code></pre>"},{"location":"reference/pydantic_discriminated/#pydantic_discriminated.DiscriminatedBaseModel.serialize_model","title":"<code>serialize_model()</code>","text":"<p>Custom serializer that includes discriminator fields only when requested.</p> <p>This method is used by Pydantic's serialization system to convert the model to a dictionary. It includes the discriminator fields, which can later be filtered out by model_dump if needed.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary representation of the model, including discriminator fields.</p> Source code in <code>src/pydantic_discriminated/api.py</code> <pre><code>@model_serializer\ndef serialize_model(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Custom serializer that includes discriminator fields only when requested.\n\n    This method is used by Pydantic's serialization system to convert the model\n    to a dictionary. It includes the discriminator fields, which can later be\n    filtered out by model_dump if needed.\n\n    Returns:\n        (dict): Dictionary representation of the model, including discriminator fields.\n    \"\"\"\n    # Get all field values without special handling\n    data = {k: v for k, v in self.__dict__.items() if not k.startswith(\"_\")}\n\n    # Add discriminator fields if configured to do so in global settings\n    # These will be filtered in model_dump if needed\n    if self._discriminator_field and self._discriminator_value is not None:\n        data[self._discriminator_field] = self._discriminator_value\n\n    # Add standard fields if configured\n    if self._use_standard_fields:\n        data[DiscriminatedConfig.standard_category_field] = self._discriminator_field\n        data[DiscriminatedConfig.standard_value_field] = self._discriminator_value\n\n    return data\n</code></pre>"},{"location":"reference/pydantic_discriminated/#pydantic_discriminated.DiscriminatedBaseModel.validate_discriminated","title":"<code>validate_discriminated(data)</code>  <code>classmethod</code>","text":"<p>Validate and return the appropriate discriminated model based on the discriminator value.</p> <p>This method looks at the discriminator fields in the data and dispatches to the appropriate model class based on the discriminator value.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict[str, Any]</code> <p>The data to validate.</p> required <p>Returns:</p> Type Description <code>DiscriminatedBaseModel</code> <p>An instance of the appropriate discriminated model.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no discriminator fields are found in the data.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; data = {\"shape_type\": \"circle\", \"radius\": 5}\n&gt;&gt;&gt; shape = DiscriminatedBaseModel.validate_discriminated(data)\n&gt;&gt;&gt; isinstance(shape, Circle)\nTrue\n</code></pre> Source code in <code>src/pydantic_discriminated/api.py</code> <pre><code>@classmethod\ndef validate_discriminated(cls, data: Dict[str, Any]) -&gt; \"DiscriminatedBaseModel\":\n    \"\"\"\n    Validate and return the appropriate discriminated model based on the discriminator value.\n\n    This method looks at the discriminator fields in the data and dispatches\n    to the appropriate model class based on the discriminator value.\n\n    Args:\n        data: The data to validate.\n\n    Returns:\n        An instance of the appropriate discriminated model.\n\n    Raises:\n        ValueError: If no discriminator fields are found in the data.\n\n    Examples:\n        &gt;&gt;&gt; data = {\"shape_type\": \"circle\", \"radius\": 5}\n        &gt;&gt;&gt; shape = DiscriminatedBaseModel.validate_discriminated(data)\n        &gt;&gt;&gt; isinstance(shape, Circle)\n        True\n    \"\"\"\n    use_standard_fields = getattr(\n        cls, \"_use_standard_fields\", DiscriminatedConfig.use_standard_fields\n    )\n\n    # First check standard discriminator fields if configured\n    if (\n        use_standard_fields\n        and DiscriminatedConfig.standard_category_field in data\n        and DiscriminatedConfig.standard_value_field in data\n    ):\n\n        category = data[DiscriminatedConfig.standard_category_field]\n        value = data[DiscriminatedConfig.standard_value_field]\n\n    # Fall back to domain-specific field\n    elif cls._discriminator_field and cls._discriminator_field in data:\n        category = cls._discriminator_field\n        value = data[cls._discriminator_field]\n    else:\n        raise ValueError(f\"No discriminator fields found in data\")\n\n    # Get the appropriate model class\n    model_cls = DiscriminatedModelRegistry.get_model(category, value)\n\n    # Validate with the model class\n    return model_cls.model_validate(data)\n</code></pre>"},{"location":"reference/pydantic_discriminated/#pydantic_discriminated.DiscriminatedConfig","title":"<code>DiscriminatedConfig</code>","text":"<p>Global configuration for discriminated models.</p> <p>This class contains settings that control how discriminated models behave, including whether to use standard fields, field naming, and monkey patching behavior.</p> <p>Attributes:</p> Name Type Description <code>use_standard_fields</code> <code>bool</code> <p>Whether to include standard discriminator fields in addition to domain-specific ones. Default is True.</p> <code>standard_category_field</code> <code>str</code> <p>The field name for the standard category field. Default is \"discriminator_category\".</p> <code>standard_value_field</code> <code>str</code> <p>The field name for the standard value field. Default is \"discriminator_value\".</p> <code>patch_base_model</code> <code>bool</code> <p>Flag to control whether to patch BaseModel. Default is True.</p> <code>_patched</code> <code>bool</code> <p>Internal flag to track if patching has been applied. Default is False.</p> Source code in <code>src/pydantic_discriminated/api.py</code> <pre><code>class DiscriminatedConfig:\n    \"\"\"\n    Global configuration for discriminated models.\n\n    This class contains settings that control how discriminated models behave,\n    including whether to use standard fields, field naming, and monkey patching behavior.\n\n    Attributes:\n        use_standard_fields (bool): Whether to include standard discriminator fields\n            in addition to domain-specific ones. Default is True.\n        standard_category_field (str): The field name for the standard category field.\n            Default is \"discriminator_category\".\n        standard_value_field (str): The field name for the standard value field.\n            Default is \"discriminator_value\".\n        patch_base_model (bool): Flag to control whether to patch BaseModel.\n            Default is True.\n        _patched (bool): Internal flag to track if patching has been applied.\n            Default is False.\n    \"\"\"\n\n    use_standard_fields: bool = True\n    standard_category_field: str = \"discriminator_category\"\n    standard_value_field: str = \"discriminator_value\"\n\n    # Flag to control whether to patch BaseModel\n    patch_base_model: bool = True\n\n    # Flag to track if patching has already been applied\n    _patched: bool = False\n\n    @classmethod\n    def enable_monkey_patching(cls):\n        \"\"\"\n        Enable monkey patching of BaseModel for discriminator support in all models.\n\n        This method enables the automatic inclusion of discriminator fields in\n        serialized output from any Pydantic model. It applies the patch if not\n        already applied.\n\n        Examples:\n            &gt;&gt;&gt; from pydantic_discriminated import DiscriminatedConfig\n            &gt;&gt;&gt; DiscriminatedConfig.enable_monkey_patching()\n        \"\"\"\n        cls.patch_base_model = True\n        # Apply the patch if not already applied\n        if not cls._patched:\n            _apply_monkey_patch()\n\n    @classmethod\n    def disable_monkey_patching(cls):\n        \"\"\"\n        Disable monkey patching of BaseModel.\n\n        When disabled, users must use DiscriminatorAwareBaseModel for containers\n        that need to preserve discriminator information in serialized output.\n        The flag is changed but the patch remains applied to avoid runtime changes\n        to method references.\n\n        Examples:\n            &gt;&gt;&gt; from pydantic_discriminated import DiscriminatedConfig\n            &gt;&gt;&gt; DiscriminatedConfig.disable_monkey_patching()\n        \"\"\"\n        print(\"DEBUG: Disabling monkey patching, previous value:\", cls.patch_base_model)\n        cls.patch_base_model = False\n        print(\"DEBUG: After disabling, new value:\", cls.patch_base_model)\n</code></pre>"},{"location":"reference/pydantic_discriminated/#pydantic_discriminated.DiscriminatedConfig.disable_monkey_patching","title":"<code>disable_monkey_patching()</code>  <code>classmethod</code>","text":"<p>Disable monkey patching of BaseModel.</p> <p>When disabled, users must use DiscriminatorAwareBaseModel for containers that need to preserve discriminator information in serialized output. The flag is changed but the patch remains applied to avoid runtime changes to method references.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pydantic_discriminated import DiscriminatedConfig\n&gt;&gt;&gt; DiscriminatedConfig.disable_monkey_patching()\n</code></pre> Source code in <code>src/pydantic_discriminated/api.py</code> <pre><code>@classmethod\ndef disable_monkey_patching(cls):\n    \"\"\"\n    Disable monkey patching of BaseModel.\n\n    When disabled, users must use DiscriminatorAwareBaseModel for containers\n    that need to preserve discriminator information in serialized output.\n    The flag is changed but the patch remains applied to avoid runtime changes\n    to method references.\n\n    Examples:\n        &gt;&gt;&gt; from pydantic_discriminated import DiscriminatedConfig\n        &gt;&gt;&gt; DiscriminatedConfig.disable_monkey_patching()\n    \"\"\"\n    print(\"DEBUG: Disabling monkey patching, previous value:\", cls.patch_base_model)\n    cls.patch_base_model = False\n    print(\"DEBUG: After disabling, new value:\", cls.patch_base_model)\n</code></pre>"},{"location":"reference/pydantic_discriminated/#pydantic_discriminated.DiscriminatedConfig.enable_monkey_patching","title":"<code>enable_monkey_patching()</code>  <code>classmethod</code>","text":"<p>Enable monkey patching of BaseModel for discriminator support in all models.</p> <p>This method enables the automatic inclusion of discriminator fields in serialized output from any Pydantic model. It applies the patch if not already applied.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pydantic_discriminated import DiscriminatedConfig\n&gt;&gt;&gt; DiscriminatedConfig.enable_monkey_patching()\n</code></pre> Source code in <code>src/pydantic_discriminated/api.py</code> <pre><code>@classmethod\ndef enable_monkey_patching(cls):\n    \"\"\"\n    Enable monkey patching of BaseModel for discriminator support in all models.\n\n    This method enables the automatic inclusion of discriminator fields in\n    serialized output from any Pydantic model. It applies the patch if not\n    already applied.\n\n    Examples:\n        &gt;&gt;&gt; from pydantic_discriminated import DiscriminatedConfig\n        &gt;&gt;&gt; DiscriminatedConfig.enable_monkey_patching()\n    \"\"\"\n    cls.patch_base_model = True\n    # Apply the patch if not already applied\n    if not cls._patched:\n        _apply_monkey_patch()\n</code></pre>"},{"location":"reference/pydantic_discriminated/#pydantic_discriminated.DiscriminatedModelRegistry","title":"<code>DiscriminatedModelRegistry</code>","text":"<p>Registry to store and retrieve discriminated models.</p> <p>This class maintains a registry of discriminated models indexed by their category and discriminator value, allowing lookup of the appropriate model class at validation time.</p> <p>Attributes:</p> Name Type Description <code>_registry</code> <code>Dict[str, Dict[Any, Type[DiscriminatedBaseModel]]]</code> <p>Internal registry storing models by category and discriminator value.</p> Source code in <code>src/pydantic_discriminated/api.py</code> <pre><code>class DiscriminatedModelRegistry:\n    \"\"\"\n    Registry to store and retrieve discriminated models.\n\n    This class maintains a registry of discriminated models indexed by their\n    category and discriminator value, allowing lookup of the appropriate model class\n    at validation time.\n\n    Attributes:\n        _registry (Dict[str, Dict[Any, Type[\"DiscriminatedBaseModel\"]]]): Internal registry\n            storing models by category and discriminator value.\n    \"\"\"\n\n    _registry: Dict[str, Dict[Any, Type[\"DiscriminatedBaseModel\"]]] = {}\n\n    @classmethod\n    def register(cls, category: str, value: Any, model_cls: Type[\"DiscriminatedBaseModel\"]) -&gt; None:\n        \"\"\"\n        Register a model class for a specific category and discriminator value.\n\n        Args:\n            category (str): The discriminator category (field name).\n            value (Any): The discriminator value.\n            model_cls : The model class to register.\n\n        Examples:\n            &gt;&gt;&gt; DiscriminatedModelRegistry.register(\"shape_type\", \"circle\", Circle)\n        \"\"\"\n        if category not in cls._registry:\n            cls._registry[category] = {}\n        cls._registry[category][value] = model_cls\n\n    @classmethod\n    def get_model(cls, category: str, value: Any) -&gt; Type[\"DiscriminatedBaseModel\"]:\n        \"\"\"\n        Get a model class by category and discriminator value.\n\n        Args:\n            category: The discriminator category (field name).\n            value: The discriminator value.\n\n        Returns:\n            Type[\"DiscriminatedBaseModel\"]: The model class registered for this category and value.\n\n        Raises:\n            ValueError: If no model is registered for the given category and value.\n\n        Examples:\n            &gt;&gt;&gt; model_cls = DiscriminatedModelRegistry.get_model(\"shape_type\", \"circle\")\n            &gt;&gt;&gt; instance = model_cls(radius=5)\n        \"\"\"\n        if category not in cls._registry:\n            raise ValueError(f\"No models registered for category '{category}'\")\n        if value not in cls._registry[category]:\n            raise ValueError(f\"No model found for value '{value}' in category '{category}'\")\n        return cls._registry[category][value]\n\n    @classmethod\n    def get_models_for_category(cls, category: str) -&gt; Dict[Any, Type[\"DiscriminatedBaseModel\"]]:\n        \"\"\"\n        Get all models registered for a specific category.\n\n        Args:\n            category: The discriminator category (field name).\n\n        Returns:\n            Dict[Any, Type[\"DiscriminatedBaseModel\"]]: Dictionary mapping discriminator values\n                to model classes for the specified category.\n\n        Raises:\n            ValueError: If no models are registered for the given category.\n\n        Examples:\n            &gt;&gt;&gt; models = DiscriminatedModelRegistry.get_models_for_category(\"shape_type\")\n            &gt;&gt;&gt; for value, model_cls in models.items():\n            ...     print(f\"{value}: {model_cls.__name__}\")\n        \"\"\"\n        if category not in cls._registry:\n            raise ValueError(f\"No models registered for category '{category}'\")\n        return cls._registry[category]\n</code></pre>"},{"location":"reference/pydantic_discriminated/#pydantic_discriminated.DiscriminatedModelRegistry.get_model","title":"<code>get_model(category, value)</code>  <code>classmethod</code>","text":"<p>Get a model class by category and discriminator value.</p> <p>Parameters:</p> Name Type Description Default <code>category</code> <code>str</code> <p>The discriminator category (field name).</p> required <code>value</code> <code>Any</code> <p>The discriminator value.</p> required <p>Returns:</p> Type Description <code>Type[DiscriminatedBaseModel]</code> <p>Type[\"DiscriminatedBaseModel\"]: The model class registered for this category and value.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no model is registered for the given category and value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; model_cls = DiscriminatedModelRegistry.get_model(\"shape_type\", \"circle\")\n&gt;&gt;&gt; instance = model_cls(radius=5)\n</code></pre> Source code in <code>src/pydantic_discriminated/api.py</code> <pre><code>@classmethod\ndef get_model(cls, category: str, value: Any) -&gt; Type[\"DiscriminatedBaseModel\"]:\n    \"\"\"\n    Get a model class by category and discriminator value.\n\n    Args:\n        category: The discriminator category (field name).\n        value: The discriminator value.\n\n    Returns:\n        Type[\"DiscriminatedBaseModel\"]: The model class registered for this category and value.\n\n    Raises:\n        ValueError: If no model is registered for the given category and value.\n\n    Examples:\n        &gt;&gt;&gt; model_cls = DiscriminatedModelRegistry.get_model(\"shape_type\", \"circle\")\n        &gt;&gt;&gt; instance = model_cls(radius=5)\n    \"\"\"\n    if category not in cls._registry:\n        raise ValueError(f\"No models registered for category '{category}'\")\n    if value not in cls._registry[category]:\n        raise ValueError(f\"No model found for value '{value}' in category '{category}'\")\n    return cls._registry[category][value]\n</code></pre>"},{"location":"reference/pydantic_discriminated/#pydantic_discriminated.DiscriminatedModelRegistry.get_models_for_category","title":"<code>get_models_for_category(category)</code>  <code>classmethod</code>","text":"<p>Get all models registered for a specific category.</p> <p>Parameters:</p> Name Type Description Default <code>category</code> <code>str</code> <p>The discriminator category (field name).</p> required <p>Returns:</p> Type Description <code>Dict[Any, Type[DiscriminatedBaseModel]]</code> <p>Dict[Any, Type[\"DiscriminatedBaseModel\"]]: Dictionary mapping discriminator values to model classes for the specified category.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no models are registered for the given category.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; models = DiscriminatedModelRegistry.get_models_for_category(\"shape_type\")\n&gt;&gt;&gt; for value, model_cls in models.items():\n...     print(f\"{value}: {model_cls.__name__}\")\n</code></pre> Source code in <code>src/pydantic_discriminated/api.py</code> <pre><code>@classmethod\ndef get_models_for_category(cls, category: str) -&gt; Dict[Any, Type[\"DiscriminatedBaseModel\"]]:\n    \"\"\"\n    Get all models registered for a specific category.\n\n    Args:\n        category: The discriminator category (field name).\n\n    Returns:\n        Dict[Any, Type[\"DiscriminatedBaseModel\"]]: Dictionary mapping discriminator values\n            to model classes for the specified category.\n\n    Raises:\n        ValueError: If no models are registered for the given category.\n\n    Examples:\n        &gt;&gt;&gt; models = DiscriminatedModelRegistry.get_models_for_category(\"shape_type\")\n        &gt;&gt;&gt; for value, model_cls in models.items():\n        ...     print(f\"{value}: {model_cls.__name__}\")\n    \"\"\"\n    if category not in cls._registry:\n        raise ValueError(f\"No models registered for category '{category}'\")\n    return cls._registry[category]\n</code></pre>"},{"location":"reference/pydantic_discriminated/#pydantic_discriminated.DiscriminatedModelRegistry.register","title":"<code>register(category, value, model_cls)</code>  <code>classmethod</code>","text":"<p>Register a model class for a specific category and discriminator value.</p> <p>Parameters:</p> Name Type Description Default <code>category</code> <code>str</code> <p>The discriminator category (field name).</p> required <code>value</code> <code>Any</code> <p>The discriminator value.</p> required <code>model_cls</code> <p>The model class to register.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; DiscriminatedModelRegistry.register(\"shape_type\", \"circle\", Circle)\n</code></pre> Source code in <code>src/pydantic_discriminated/api.py</code> <pre><code>@classmethod\ndef register(cls, category: str, value: Any, model_cls: Type[\"DiscriminatedBaseModel\"]) -&gt; None:\n    \"\"\"\n    Register a model class for a specific category and discriminator value.\n\n    Args:\n        category (str): The discriminator category (field name).\n        value (Any): The discriminator value.\n        model_cls : The model class to register.\n\n    Examples:\n        &gt;&gt;&gt; DiscriminatedModelRegistry.register(\"shape_type\", \"circle\", Circle)\n    \"\"\"\n    if category not in cls._registry:\n        cls._registry[category] = {}\n    cls._registry[category][value] = model_cls\n</code></pre>"},{"location":"reference/pydantic_discriminated/#pydantic_discriminated.DiscriminatorAwareBaseModel","title":"<code>DiscriminatorAwareBaseModel</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base model that handles discriminators in serialization, including nested models.</p> <p>Use this as a base class for container models when monkey patching is disabled. This class ensures that discriminator fields are properly included in serialized output even when the global monkey patching is disabled.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class Container(DiscriminatorAwareBaseModel):\n...     shape: Circle\n&gt;&gt;&gt; container = Container(shape=Circle(radius=5))\n&gt;&gt;&gt; data = container.model_dump()  # Will include discriminator fields\n</code></pre> Source code in <code>src/pydantic_discriminated/api.py</code> <pre><code>class DiscriminatorAwareBaseModel(BaseModel):\n    \"\"\"\n    Base model that handles discriminators in serialization, including nested models.\n\n    Use this as a base class for container models when monkey patching is disabled.\n    This class ensures that discriminator fields are properly included in serialized\n    output even when the global monkey patching is disabled.\n\n    Examples:\n        &gt;&gt;&gt; class Container(DiscriminatorAwareBaseModel):\n        ...     shape: Circle\n        &gt;&gt;&gt; container = Container(shape=Circle(radius=5))\n        &gt;&gt;&gt; data = container.model_dump()  # Will include discriminator fields\n    \"\"\"\n\n    def model_dump(self, **kwargs: Any) -&gt; Dict[str, Any]:\n        \"\"\"\n        Override model_dump to include discriminators at all nesting levels.\n\n        This method ensures that discriminator fields are included in the serialized\n        output regardless of the global monkey patching setting.\n\n        Args:\n            **kwargs: Keyword arguments to pass to the parent model_dump method.\n\n        Returns:\n            (dict): The serialized model with discriminator fields included.\n        \"\"\"\n        # Always use discriminators for this class by setting the flag\n        kwargs[\"use_discriminators\"] = True\n\n        # Get standard serialization with discriminators\n        if DiscriminatedConfig._patched:\n            # If BaseModel is patched, use the patched method with our flag\n            return super().model_dump(**kwargs)\n        else:\n            # If not patched, use the original method and process it ourselves\n            result = super().model_dump(**kwargs)\n            return _process_discriminators(self, result)\n\n    def model_dump_json(self, **kwargs: Any) -&gt; str:\n        \"\"\"\n        Override model_dump_json to include discriminators at all nesting levels.\n\n        This method ensures that discriminator fields are included in the JSON\n        serialized output regardless of the global monkey patching setting.\n\n        Args:\n            **kwargs: Keyword arguments to pass to the parent model_dump_json method.\n\n        Returns:\n            (str): The JSON string representation of the model with discriminator fields included.\n        \"\"\"\n        # Always use discriminators for this class\n        kwargs[\"use_discriminators\"] = True\n\n        # Get data with discriminators (will use our overridden model_dump)\n        if DiscriminatedConfig._patched:\n            # If patched, use the patched method with our flag\n            return super().model_dump_json(**kwargs)\n        else:\n            # If not patched, get data and convert to JSON ourselves\n            data = self.model_dump(**kwargs)\n            encoder = kwargs.pop(\"encoder\", None)\n            return json.dumps(data, default=encoder, **kwargs)\n</code></pre>"},{"location":"reference/pydantic_discriminated/#pydantic_discriminated.DiscriminatorAwareBaseModel.model_dump","title":"<code>model_dump(**kwargs)</code>","text":"<p>Override model_dump to include discriminators at all nesting levels.</p> <p>This method ensures that discriminator fields are included in the serialized output regardless of the global monkey patching setting.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Keyword arguments to pass to the parent model_dump method.</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict</code> <p>The serialized model with discriminator fields included.</p> Source code in <code>src/pydantic_discriminated/api.py</code> <pre><code>def model_dump(self, **kwargs: Any) -&gt; Dict[str, Any]:\n    \"\"\"\n    Override model_dump to include discriminators at all nesting levels.\n\n    This method ensures that discriminator fields are included in the serialized\n    output regardless of the global monkey patching setting.\n\n    Args:\n        **kwargs: Keyword arguments to pass to the parent model_dump method.\n\n    Returns:\n        (dict): The serialized model with discriminator fields included.\n    \"\"\"\n    # Always use discriminators for this class by setting the flag\n    kwargs[\"use_discriminators\"] = True\n\n    # Get standard serialization with discriminators\n    if DiscriminatedConfig._patched:\n        # If BaseModel is patched, use the patched method with our flag\n        return super().model_dump(**kwargs)\n    else:\n        # If not patched, use the original method and process it ourselves\n        result = super().model_dump(**kwargs)\n        return _process_discriminators(self, result)\n</code></pre>"},{"location":"reference/pydantic_discriminated/#pydantic_discriminated.DiscriminatorAwareBaseModel.model_dump_json","title":"<code>model_dump_json(**kwargs)</code>","text":"<p>Override model_dump_json to include discriminators at all nesting levels.</p> <p>This method ensures that discriminator fields are included in the JSON serialized output regardless of the global monkey patching setting.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Keyword arguments to pass to the parent model_dump_json method.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The JSON string representation of the model with discriminator fields included.</p> Source code in <code>src/pydantic_discriminated/api.py</code> <pre><code>def model_dump_json(self, **kwargs: Any) -&gt; str:\n    \"\"\"\n    Override model_dump_json to include discriminators at all nesting levels.\n\n    This method ensures that discriminator fields are included in the JSON\n    serialized output regardless of the global monkey patching setting.\n\n    Args:\n        **kwargs: Keyword arguments to pass to the parent model_dump_json method.\n\n    Returns:\n        (str): The JSON string representation of the model with discriminator fields included.\n    \"\"\"\n    # Always use discriminators for this class\n    kwargs[\"use_discriminators\"] = True\n\n    # Get data with discriminators (will use our overridden model_dump)\n    if DiscriminatedConfig._patched:\n        # If patched, use the patched method with our flag\n        return super().model_dump_json(**kwargs)\n    else:\n        # If not patched, get data and convert to JSON ourselves\n        data = self.model_dump(**kwargs)\n        encoder = kwargs.pop(\"encoder\", None)\n        return json.dumps(data, default=encoder, **kwargs)\n</code></pre>"},{"location":"reference/pydantic_discriminated/#pydantic_discriminated.discriminated_model","title":"<code>discriminated_model(category, discriminator, use_standard_fields=None)</code>","text":"<p>Decorator to create a discriminated model.</p> <p>This decorator registers a model class with the DiscriminatedModelRegistry and sets up the discriminator field and value.</p> <p>Parameters:</p> Name Type Description Default <code>category</code> <code>Union[str, Type[Enum]]</code> <p>The category field name or Enum class. If an Enum class is provided, its lowercase name is used as the field name.</p> required <code>discriminator</code> <code>Any</code> <p>The discriminator value for this model.</p> required <code>use_standard_fields</code> <code>Optional[bool]</code> <p>Whether to use standard discriminator fields. Defaults to the global setting in DiscriminatedConfig.</p> <code>None</code> <p>Returns:</p> Type Description <code>Callable[[Type[T]], Type[T]]</code> <p>A decorator function that registers the model class.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; @discriminated_model(\"shape_type\", \"circle\")\n... class Circle(DiscriminatedBaseModel):\n...     radius: float\n</code></pre> <pre><code>&gt;&gt;&gt; from enum import Enum\n&gt;&gt;&gt; class ShapeType(str, Enum):\n...     CIRCLE = \"circle\"\n...     RECTANGLE = \"rectangle\"\n&gt;&gt;&gt; @discriminated_model(ShapeType, ShapeType.CIRCLE)\n... class Circle(DiscriminatedBaseModel):\n...     radius: float\n</code></pre> Source code in <code>src/pydantic_discriminated/api.py</code> <pre><code>def discriminated_model(\n    category: Union[str, Type[Enum]],\n    discriminator: Any,\n    use_standard_fields: Optional[bool] = None,\n) -&gt; Callable[[Type[T]], Type[T]]:\n    \"\"\"\n    Decorator to create a discriminated model.\n\n    This decorator registers a model class with the DiscriminatedModelRegistry\n    and sets up the discriminator field and value.\n\n    Args:\n        category: The category field name or Enum class. If an Enum class is provided,\n            its lowercase name is used as the field name.\n        discriminator: The discriminator value for this model.\n        use_standard_fields: Whether to use standard discriminator fields.\n            Defaults to the global setting in DiscriminatedConfig.\n\n    Returns:\n        A decorator function that registers the model class.\n\n    Examples:\n        &gt;&gt;&gt; @discriminated_model(\"shape_type\", \"circle\")\n        ... class Circle(DiscriminatedBaseModel):\n        ...     radius: float\n\n        &gt;&gt;&gt; from enum import Enum\n        &gt;&gt;&gt; class ShapeType(str, Enum):\n        ...     CIRCLE = \"circle\"\n        ...     RECTANGLE = \"rectangle\"\n        &gt;&gt;&gt; @discriminated_model(ShapeType, ShapeType.CIRCLE)\n        ... class Circle(DiscriminatedBaseModel):\n        ...     radius: float\n    \"\"\"\n    category_field = category\n    if isinstance(category, type) and issubclass(category, Enum):\n        category_field = category.__name__.lower()\n\n    field_name = str(category_field)\n\n    def decorator(cls: Type[T]) -&gt; Type[T]:\n        \"\"\"\n        The actual decorator function that transforms the model class.\n\n        This inner function registers the model class with the DiscriminatedModelRegistry,\n        sets up discriminator attributes, and overrides __init__ to ensure discriminator\n        values are set correctly.\n\n        Args:\n            cls: The model class to decorate.\n\n        Returns:\n            The decorated model class.\n\n        Raises:\n            TypeError: If the class doesn't inherit from DiscriminatedBaseModel.\n        \"\"\"\n        # Make sure the class inherits from DiscriminatedBaseModel\n        if not issubclass(cls, DiscriminatedBaseModel):\n            raise TypeError(f\"{cls.__name__} must inherit from DiscriminatedBaseModel\")\n\n        # Register the model\n        DiscriminatedModelRegistry.register(field_name, discriminator, cls)\n\n        # Store the discriminator information as class variables\n        cls._discriminator_field = field_name\n        cls._discriminator_value = discriminator\n\n        # Set standard fields configuration\n        if use_standard_fields is not None:\n            cls._use_standard_fields = use_standard_fields\n        elif hasattr(cls, \"model_config\") and \"use_standard_fields\" in cls.model_config:\n            cls._use_standard_fields = cls.model_config[\"use_standard_fields\"]\n        else:\n            cls._use_standard_fields = DiscriminatedConfig.use_standard_fields\n\n        # Add the discriminator fields to the model's annotations\n        if not hasattr(cls, \"__annotations__\"):\n            cls.__annotations__ = {}\n\n        # Determine the type of the discriminator field\n        if isinstance(discriminator, Enum):\n            field_type = type(discriminator)\n        else:\n            field_type = type(discriminator)\n\n        # Add domain-specific field to annotations\n        cls.__annotations__[field_name] = field_type\n\n        # Add standard fields to annotations if configured\n        if cls._use_standard_fields:\n            cls.__annotations__[DiscriminatedConfig.standard_category_field] = str\n            cls.__annotations__[DiscriminatedConfig.standard_value_field] = field_type\n\n        # Update model_config to exclude discriminator fields by default\n        if not hasattr(cls, \"model_config\"):\n            cls.model_config = {}\n\n        # Get existing excluded fields or create an empty set\n        excluded = cls.model_config.get(\"excluded\", set())\n        if isinstance(excluded, list):\n            excluded = set(excluded)\n\n        # Add discriminator fields to excluded\n        excluded.add(field_name)\n        if cls._use_standard_fields:\n            excluded.add(DiscriminatedConfig.standard_category_field)\n            excluded.add(DiscriminatedConfig.standard_value_field)\n\n        cls.model_config[\"excluded\"] = excluded\n\n        # Override __init__ to set the discriminator values\n        original_init = cls.__init__\n\n        def init_with_discriminator(self, **data):\n            \"\"\"\n            Overridden __init__ that ensures discriminator values are set correctly.\n\n            This function adds the discriminator field and value to the initialization\n            data if missing, then calls the original __init__, and finally ensures\n            that discriminator attributes are set on the instance.\n\n            Args:\n                **data (dict[Any, Any]): Keyword arguments for initialization.\n            \"\"\"\n            # Add domain-specific discriminator field if missing\n            if field_name not in data:\n                data[field_name] = discriminator\n\n            # Add standard fields if configured\n            use_std_fields = cls._use_standard_fields\n            if use_std_fields:\n                if DiscriminatedConfig.standard_category_field not in data:\n                    data[DiscriminatedConfig.standard_category_field] = field_name\n                if DiscriminatedConfig.standard_value_field not in data:\n                    data[DiscriminatedConfig.standard_value_field] = discriminator\n\n            original_init(self, **data)\n\n            # Ensure discriminator values are set as instance attributes\n            object.__setattr__(self, field_name, discriminator)\n            object.__setattr__(self, \"_discriminator_field\", field_name)\n            object.__setattr__(self, \"_discriminator_value\", discriminator)\n            object.__setattr__(self, \"_use_standard_fields\", use_std_fields)\n\n            # Set standard fields if configured\n            if use_std_fields:\n                object.__setattr__(self, DiscriminatedConfig.standard_category_field, field_name)\n                object.__setattr__(self, DiscriminatedConfig.standard_value_field, discriminator)\n\n        cls.__init__ = init_with_discriminator\n\n        return cls\n\n    return decorator\n</code></pre>"},{"location":"reference/pydantic_discriminated/api/","title":"api","text":"<p>Pydantic Discriminated Union Support</p> <p>This module provides functionality for working with discriminated unions in Pydantic models. Discriminated unions allow handling polymorphic data structures in a type-safe way by using a \"discriminator\" field to indicate the concrete type.</p> <p>The module supports: - Decorating models with discriminator information - Automatic serialization with discriminator fields - Registry for looking up model types by discriminator values - Optional monkey patching of Pydantic's BaseModel for seamless integration</p>"},{"location":"reference/pydantic_discriminated/api/#pydantic_discriminated.api.DiscriminatedBaseModel","title":"<code>DiscriminatedBaseModel</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base class for discriminated models that ensures discriminator fields are included in serialization only when requested.</p> <p>This class must be used as the base class for all models that will be part of a discriminated union. It provides methods for validating and serializing discriminated models.</p> <p>Attributes:</p> Name Type Description <code>_discriminator_field</code> <code>ClassVar[str]</code> <p>The discriminator field name.</p> <code>_discriminator_value</code> <code>ClassVar[Any]</code> <p>The discriminator value for this model.</p> <code>_use_standard_fields</code> <code>ClassVar[bool]</code> <p>Whether to use standard discriminator fields. Defaults to the global setting in DiscriminatedConfig.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; @discriminated_model(\"shape_type\", \"circle\")\n... class Circle(DiscriminatedBaseModel):\n...     radius: float\n&gt;&gt;&gt; circle = Circle(radius=5)\n&gt;&gt;&gt; data = circle.model_dump()  # Includes discriminator fields\n</code></pre> Source code in <code>src/pydantic_discriminated/api.py</code> <pre><code>class DiscriminatedBaseModel(BaseModel):\n    \"\"\"\n    Base class for discriminated models that ensures discriminator fields are included\n    in serialization only when requested.\n\n    This class must be used as the base class for all models that will be part of\n    a discriminated union. It provides methods for validating and serializing\n    discriminated models.\n\n    Attributes:\n        _discriminator_field (ClassVar[str]): The discriminator field name.\n        _discriminator_value (ClassVar[Any]): The discriminator value for this model.\n        _use_standard_fields (ClassVar[bool]): Whether to use standard discriminator fields.\n            Defaults to the global setting in DiscriminatedConfig.\n\n    Examples:\n        &gt;&gt;&gt; @discriminated_model(\"shape_type\", \"circle\")\n        ... class Circle(DiscriminatedBaseModel):\n        ...     radius: float\n        &gt;&gt;&gt; circle = Circle(radius=5)\n        &gt;&gt;&gt; data = circle.model_dump()  # Includes discriminator fields\n    \"\"\"\n\n    # Legacy fields for compatibility\n    _discriminator_field: ClassVar[str] = \"\"\n    _discriminator_value: ClassVar[Any] = None\n    _use_standard_fields: ClassVar[bool] = DiscriminatedConfig.use_standard_fields\n\n    def __getattr__(self, name: str) -&gt; Any:\n        \"\"\"\n        Custom attribute access to handle discriminator field.\n\n        This method allows accessing the discriminator value through the discriminator\n        field name, as well as through the standard discriminator fields.\n\n        Args:\n            name (str): The attribute name being accessed.\n\n        Returns:\n            (Any): The discriminator value if name is the discriminator field or a standard\n            discriminator field, otherwise raises AttributeError.\n\n        Raises:\n            (AttributeError): If the attribute doesn't exist and isn't a discriminator field.\n        \"\"\"\n        # Handle access to the legacy discriminator field\n        if name == self._discriminator_field:\n            return self._discriminator_value\n\n        # Handle access to standard discriminator fields\n        if name == DiscriminatedConfig.standard_category_field:\n            return self._discriminator_field\n        if name == DiscriminatedConfig.standard_value_field:\n            return self._discriminator_value\n\n        # Default behavior for other attributes\n        return super().__getattr__(name)\n\n    def model_dump(self, **kwargs: Any):\n        \"\"\"\n        Override model_dump to control when discriminators are included.\n\n        This method allows controlling whether discriminator fields are included\n        in the serialized output using the use_discriminators parameter or the\n        global setting.\n\n        Args:\n            **kwargs: Keyword arguments to pass to the parent model_dump method.\n                A special 'use_discriminators' parameter can be passed to override\n                the global setting.\n\n        Returns:\n            (dict): The serialized model with discriminator fields included or excluded\n                based on configuration.\n        \"\"\"\n        # Extract our custom parameter or use the global setting\n        use_discriminators = kwargs.pop(\"use_discriminators\", DiscriminatedConfig.patch_base_model)\n        print(f\"DEBUG DiscriminatedBaseModel.model_dump: use_discriminators={use_discriminators}\")\n\n        # Get the result from the original method (without our custom parameter)\n        if DiscriminatedConfig._patched:\n            # If patched, use the original method via the global store\n            # Make a copy of kwargs to avoid modifying the original\n            kwargs_copy = kwargs.copy()\n            if \"use_discriminators\" in kwargs_copy:\n                del kwargs_copy[\"use_discriminators\"]\n            data = _original_methods[\"model_dump\"](self, **kwargs_copy)\n        else:\n            # If not patched, use the superclass method\n            data = super().model_dump(**kwargs)\n\n        # Remove discriminator fields if they shouldn't be included\n        if not use_discriminators:\n            # Remove domain-specific discriminator field\n            if self._discriminator_field in data:\n                data.pop(self._discriminator_field)\n\n            # Remove standard fields if present\n            if self._use_standard_fields:\n                if DiscriminatedConfig.standard_category_field in data:\n                    data.pop(DiscriminatedConfig.standard_category_field)\n                if DiscriminatedConfig.standard_value_field in data:\n                    data.pop(DiscriminatedConfig.standard_value_field)\n\n        return data\n\n    @model_serializer\n    def serialize_model(self) -&gt; Dict[str, Any]:\n        \"\"\"\n        Custom serializer that includes discriminator fields only when requested.\n\n        This method is used by Pydantic's serialization system to convert the model\n        to a dictionary. It includes the discriminator fields, which can later be\n        filtered out by model_dump if needed.\n\n        Returns:\n            (dict): Dictionary representation of the model, including discriminator fields.\n        \"\"\"\n        # Get all field values without special handling\n        data = {k: v for k, v in self.__dict__.items() if not k.startswith(\"_\")}\n\n        # Add discriminator fields if configured to do so in global settings\n        # These will be filtered in model_dump if needed\n        if self._discriminator_field and self._discriminator_value is not None:\n            data[self._discriminator_field] = self._discriminator_value\n\n        # Add standard fields if configured\n        if self._use_standard_fields:\n            data[DiscriminatedConfig.standard_category_field] = self._discriminator_field\n            data[DiscriminatedConfig.standard_value_field] = self._discriminator_value\n\n        return data\n\n    @classmethod\n    def model_validate(cls: Type[T], obj: Any, **kwargs: Any) -&gt; T:\n        \"\"\"\n        Validate the given object and return an instance of this model.\n\n        Enhanced to handle discriminator validation. This method checks if the\n        discriminator value in the input data matches the expected value for this\n        model class.\n\n        Args:\n            obj: The object to validate.\n            **kwargs: Additional arguments to pass to the original model_validate.\n\n        Returns:\n            An instance of this model.\n\n        Raises:\n            ValueError: If the discriminator value in the input data doesn't match\n                the expected value for this model class.\n\n        Examples:\n            &gt;&gt;&gt; data = {\"shape_type\": \"circle\", \"radius\": 5}\n            &gt;&gt;&gt; circle = Circle.model_validate(data)\n        \"\"\"\n        use_standard_fields = getattr(\n            cls, \"_use_standard_fields\", DiscriminatedConfig.use_standard_fields\n        )\n\n        if isinstance(obj, dict):\n            new_obj = obj.copy()  # Create a copy to avoid modifying the original\n\n            # Check if we have standard discriminator fields\n            if (\n                use_standard_fields\n                and DiscriminatedConfig.standard_category_field in new_obj\n                and DiscriminatedConfig.standard_value_field in new_obj\n            ):\n\n                # Use standard fields for validation\n                if new_obj[DiscriminatedConfig.standard_category_field] != cls._discriminator_field:\n                    raise ValueError(\n                        f\"Invalid discriminator category: expected {cls._discriminator_field}, \"\n                        f\"got {new_obj[DiscriminatedConfig.standard_category_field]}\"\n                    )\n                if new_obj[DiscriminatedConfig.standard_value_field] != cls._discriminator_value:\n                    raise ValueError(\n                        f\"Invalid discriminator value: expected {cls._discriminator_value}, \"\n                        f\"got {new_obj[DiscriminatedConfig.standard_value_field]}\"\n                    )\n\n            # Check legacy field if present\n            elif cls._discriminator_field and cls._discriminator_field in new_obj:\n                if new_obj[cls._discriminator_field] != cls._discriminator_value:\n                    raise ValueError(\n                        f\"Invalid discriminator value: expected {cls._discriminator_value}, \"\n                        f\"got {new_obj[cls._discriminator_field]}\"\n                    )\n\n            # Add domain-specific discriminator field if missing\n            if cls._discriminator_field and cls._discriminator_field not in new_obj:\n                new_obj[cls._discriminator_field] = cls._discriminator_value\n\n            # Add standard discriminator fields if configured and missing\n            if use_standard_fields:\n                if DiscriminatedConfig.standard_category_field not in new_obj:\n                    new_obj[DiscriminatedConfig.standard_category_field] = cls._discriminator_field\n                if DiscriminatedConfig.standard_value_field not in new_obj:\n                    new_obj[DiscriminatedConfig.standard_value_field] = cls._discriminator_value\n\n            obj = new_obj\n\n        # Call the original model_validate\n        instance = super().model_validate(obj, **kwargs)\n\n        # Set the discriminator values on the instance\n        object.__setattr__(instance, \"_discriminator_field\", cls._discriminator_field)\n        object.__setattr__(instance, \"_discriminator_value\", cls._discriminator_value)\n        object.__setattr__(instance, \"_use_standard_fields\", use_standard_fields)\n\n        # For backward compatibility, also set the domain-specific field\n        if cls._discriminator_field:\n            object.__setattr__(instance, cls._discriminator_field, cls._discriminator_value)\n\n        # Set standard fields if configured\n        if use_standard_fields:\n            object.__setattr__(\n                instance,\n                DiscriminatedConfig.standard_category_field,\n                cls._discriminator_field,\n            )\n            object.__setattr__(\n                instance,\n                DiscriminatedConfig.standard_value_field,\n                cls._discriminator_value,\n            )\n\n        return instance\n\n    @classmethod\n    def model_validate_json(cls: Type[T], json_data: Union[str, bytes], **kwargs: Any) -&gt; T:\n        \"\"\"\n        Validate the given JSON data and return an instance of this model.\n\n        Enhanced to handle discriminator validation. This method parses the JSON data\n        and then uses model_validate to validate it.\n\n        Args:\n            json_data: The JSON data to validate.\n            **kwargs: Additional arguments to pass to model_validate.\n\n        Returns:\n            An instance of this model.\n\n        Examples:\n            &gt;&gt;&gt; json_str = '{\"shape_type\": \"circle\", \"radius\": 5}'\n            &gt;&gt;&gt; circle = Circle.model_validate_json(json_str)\n        \"\"\"\n        # Parse JSON first\n        if isinstance(json_data, bytes):\n            json_data = json_data.decode()\n        data = json.loads(json_data)\n\n        # Now validate with our enhanced model_validate\n        return cls.model_validate(data, **kwargs)\n\n    @classmethod\n    def validate_discriminated(cls, data: Dict[str, Any]) -&gt; \"DiscriminatedBaseModel\":\n        \"\"\"\n        Validate and return the appropriate discriminated model based on the discriminator value.\n\n        This method looks at the discriminator fields in the data and dispatches\n        to the appropriate model class based on the discriminator value.\n\n        Args:\n            data: The data to validate.\n\n        Returns:\n            An instance of the appropriate discriminated model.\n\n        Raises:\n            ValueError: If no discriminator fields are found in the data.\n\n        Examples:\n            &gt;&gt;&gt; data = {\"shape_type\": \"circle\", \"radius\": 5}\n            &gt;&gt;&gt; shape = DiscriminatedBaseModel.validate_discriminated(data)\n            &gt;&gt;&gt; isinstance(shape, Circle)\n            True\n        \"\"\"\n        use_standard_fields = getattr(\n            cls, \"_use_standard_fields\", DiscriminatedConfig.use_standard_fields\n        )\n\n        # First check standard discriminator fields if configured\n        if (\n            use_standard_fields\n            and DiscriminatedConfig.standard_category_field in data\n            and DiscriminatedConfig.standard_value_field in data\n        ):\n\n            category = data[DiscriminatedConfig.standard_category_field]\n            value = data[DiscriminatedConfig.standard_value_field]\n\n        # Fall back to domain-specific field\n        elif cls._discriminator_field and cls._discriminator_field in data:\n            category = cls._discriminator_field\n            value = data[cls._discriminator_field]\n        else:\n            raise ValueError(f\"No discriminator fields found in data\")\n\n        # Get the appropriate model class\n        model_cls = DiscriminatedModelRegistry.get_model(category, value)\n\n        # Validate with the model class\n        return model_cls.model_validate(data)\n</code></pre>"},{"location":"reference/pydantic_discriminated/api/#pydantic_discriminated.api.DiscriminatedBaseModel.__getattr__","title":"<code>__getattr__(name)</code>","text":"<p>Custom attribute access to handle discriminator field.</p> <p>This method allows accessing the discriminator value through the discriminator field name, as well as through the standard discriminator fields.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The attribute name being accessed.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The discriminator value if name is the discriminator field or a standard</p> <code>Any</code> <p>discriminator field, otherwise raises AttributeError.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If the attribute doesn't exist and isn't a discriminator field.</p> Source code in <code>src/pydantic_discriminated/api.py</code> <pre><code>def __getattr__(self, name: str) -&gt; Any:\n    \"\"\"\n    Custom attribute access to handle discriminator field.\n\n    This method allows accessing the discriminator value through the discriminator\n    field name, as well as through the standard discriminator fields.\n\n    Args:\n        name (str): The attribute name being accessed.\n\n    Returns:\n        (Any): The discriminator value if name is the discriminator field or a standard\n        discriminator field, otherwise raises AttributeError.\n\n    Raises:\n        (AttributeError): If the attribute doesn't exist and isn't a discriminator field.\n    \"\"\"\n    # Handle access to the legacy discriminator field\n    if name == self._discriminator_field:\n        return self._discriminator_value\n\n    # Handle access to standard discriminator fields\n    if name == DiscriminatedConfig.standard_category_field:\n        return self._discriminator_field\n    if name == DiscriminatedConfig.standard_value_field:\n        return self._discriminator_value\n\n    # Default behavior for other attributes\n    return super().__getattr__(name)\n</code></pre>"},{"location":"reference/pydantic_discriminated/api/#pydantic_discriminated.api.DiscriminatedBaseModel.model_dump","title":"<code>model_dump(**kwargs)</code>","text":"<p>Override model_dump to control when discriminators are included.</p> <p>This method allows controlling whether discriminator fields are included in the serialized output using the use_discriminators parameter or the global setting.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Keyword arguments to pass to the parent model_dump method. A special 'use_discriminators' parameter can be passed to override the global setting.</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict</code> <p>The serialized model with discriminator fields included or excluded based on configuration.</p> Source code in <code>src/pydantic_discriminated/api.py</code> <pre><code>def model_dump(self, **kwargs: Any):\n    \"\"\"\n    Override model_dump to control when discriminators are included.\n\n    This method allows controlling whether discriminator fields are included\n    in the serialized output using the use_discriminators parameter or the\n    global setting.\n\n    Args:\n        **kwargs: Keyword arguments to pass to the parent model_dump method.\n            A special 'use_discriminators' parameter can be passed to override\n            the global setting.\n\n    Returns:\n        (dict): The serialized model with discriminator fields included or excluded\n            based on configuration.\n    \"\"\"\n    # Extract our custom parameter or use the global setting\n    use_discriminators = kwargs.pop(\"use_discriminators\", DiscriminatedConfig.patch_base_model)\n    print(f\"DEBUG DiscriminatedBaseModel.model_dump: use_discriminators={use_discriminators}\")\n\n    # Get the result from the original method (without our custom parameter)\n    if DiscriminatedConfig._patched:\n        # If patched, use the original method via the global store\n        # Make a copy of kwargs to avoid modifying the original\n        kwargs_copy = kwargs.copy()\n        if \"use_discriminators\" in kwargs_copy:\n            del kwargs_copy[\"use_discriminators\"]\n        data = _original_methods[\"model_dump\"](self, **kwargs_copy)\n    else:\n        # If not patched, use the superclass method\n        data = super().model_dump(**kwargs)\n\n    # Remove discriminator fields if they shouldn't be included\n    if not use_discriminators:\n        # Remove domain-specific discriminator field\n        if self._discriminator_field in data:\n            data.pop(self._discriminator_field)\n\n        # Remove standard fields if present\n        if self._use_standard_fields:\n            if DiscriminatedConfig.standard_category_field in data:\n                data.pop(DiscriminatedConfig.standard_category_field)\n            if DiscriminatedConfig.standard_value_field in data:\n                data.pop(DiscriminatedConfig.standard_value_field)\n\n    return data\n</code></pre>"},{"location":"reference/pydantic_discriminated/api/#pydantic_discriminated.api.DiscriminatedBaseModel.model_validate","title":"<code>model_validate(obj, **kwargs)</code>  <code>classmethod</code>","text":"<p>Validate the given object and return an instance of this model.</p> <p>Enhanced to handle discriminator validation. This method checks if the discriminator value in the input data matches the expected value for this model class.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>The object to validate.</p> required <code>**kwargs</code> <code>Any</code> <p>Additional arguments to pass to the original model_validate.</p> <code>{}</code> <p>Returns:</p> Type Description <code>T</code> <p>An instance of this model.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the discriminator value in the input data doesn't match the expected value for this model class.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; data = {\"shape_type\": \"circle\", \"radius\": 5}\n&gt;&gt;&gt; circle = Circle.model_validate(data)\n</code></pre> Source code in <code>src/pydantic_discriminated/api.py</code> <pre><code>@classmethod\ndef model_validate(cls: Type[T], obj: Any, **kwargs: Any) -&gt; T:\n    \"\"\"\n    Validate the given object and return an instance of this model.\n\n    Enhanced to handle discriminator validation. This method checks if the\n    discriminator value in the input data matches the expected value for this\n    model class.\n\n    Args:\n        obj: The object to validate.\n        **kwargs: Additional arguments to pass to the original model_validate.\n\n    Returns:\n        An instance of this model.\n\n    Raises:\n        ValueError: If the discriminator value in the input data doesn't match\n            the expected value for this model class.\n\n    Examples:\n        &gt;&gt;&gt; data = {\"shape_type\": \"circle\", \"radius\": 5}\n        &gt;&gt;&gt; circle = Circle.model_validate(data)\n    \"\"\"\n    use_standard_fields = getattr(\n        cls, \"_use_standard_fields\", DiscriminatedConfig.use_standard_fields\n    )\n\n    if isinstance(obj, dict):\n        new_obj = obj.copy()  # Create a copy to avoid modifying the original\n\n        # Check if we have standard discriminator fields\n        if (\n            use_standard_fields\n            and DiscriminatedConfig.standard_category_field in new_obj\n            and DiscriminatedConfig.standard_value_field in new_obj\n        ):\n\n            # Use standard fields for validation\n            if new_obj[DiscriminatedConfig.standard_category_field] != cls._discriminator_field:\n                raise ValueError(\n                    f\"Invalid discriminator category: expected {cls._discriminator_field}, \"\n                    f\"got {new_obj[DiscriminatedConfig.standard_category_field]}\"\n                )\n            if new_obj[DiscriminatedConfig.standard_value_field] != cls._discriminator_value:\n                raise ValueError(\n                    f\"Invalid discriminator value: expected {cls._discriminator_value}, \"\n                    f\"got {new_obj[DiscriminatedConfig.standard_value_field]}\"\n                )\n\n        # Check legacy field if present\n        elif cls._discriminator_field and cls._discriminator_field in new_obj:\n            if new_obj[cls._discriminator_field] != cls._discriminator_value:\n                raise ValueError(\n                    f\"Invalid discriminator value: expected {cls._discriminator_value}, \"\n                    f\"got {new_obj[cls._discriminator_field]}\"\n                )\n\n        # Add domain-specific discriminator field if missing\n        if cls._discriminator_field and cls._discriminator_field not in new_obj:\n            new_obj[cls._discriminator_field] = cls._discriminator_value\n\n        # Add standard discriminator fields if configured and missing\n        if use_standard_fields:\n            if DiscriminatedConfig.standard_category_field not in new_obj:\n                new_obj[DiscriminatedConfig.standard_category_field] = cls._discriminator_field\n            if DiscriminatedConfig.standard_value_field not in new_obj:\n                new_obj[DiscriminatedConfig.standard_value_field] = cls._discriminator_value\n\n        obj = new_obj\n\n    # Call the original model_validate\n    instance = super().model_validate(obj, **kwargs)\n\n    # Set the discriminator values on the instance\n    object.__setattr__(instance, \"_discriminator_field\", cls._discriminator_field)\n    object.__setattr__(instance, \"_discriminator_value\", cls._discriminator_value)\n    object.__setattr__(instance, \"_use_standard_fields\", use_standard_fields)\n\n    # For backward compatibility, also set the domain-specific field\n    if cls._discriminator_field:\n        object.__setattr__(instance, cls._discriminator_field, cls._discriminator_value)\n\n    # Set standard fields if configured\n    if use_standard_fields:\n        object.__setattr__(\n            instance,\n            DiscriminatedConfig.standard_category_field,\n            cls._discriminator_field,\n        )\n        object.__setattr__(\n            instance,\n            DiscriminatedConfig.standard_value_field,\n            cls._discriminator_value,\n        )\n\n    return instance\n</code></pre>"},{"location":"reference/pydantic_discriminated/api/#pydantic_discriminated.api.DiscriminatedBaseModel.model_validate_json","title":"<code>model_validate_json(json_data, **kwargs)</code>  <code>classmethod</code>","text":"<p>Validate the given JSON data and return an instance of this model.</p> <p>Enhanced to handle discriminator validation. This method parses the JSON data and then uses model_validate to validate it.</p> <p>Parameters:</p> Name Type Description Default <code>json_data</code> <code>Union[str, bytes]</code> <p>The JSON data to validate.</p> required <code>**kwargs</code> <code>Any</code> <p>Additional arguments to pass to model_validate.</p> <code>{}</code> <p>Returns:</p> Type Description <code>T</code> <p>An instance of this model.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; json_str = '{\"shape_type\": \"circle\", \"radius\": 5}'\n&gt;&gt;&gt; circle = Circle.model_validate_json(json_str)\n</code></pre> Source code in <code>src/pydantic_discriminated/api.py</code> <pre><code>@classmethod\ndef model_validate_json(cls: Type[T], json_data: Union[str, bytes], **kwargs: Any) -&gt; T:\n    \"\"\"\n    Validate the given JSON data and return an instance of this model.\n\n    Enhanced to handle discriminator validation. This method parses the JSON data\n    and then uses model_validate to validate it.\n\n    Args:\n        json_data: The JSON data to validate.\n        **kwargs: Additional arguments to pass to model_validate.\n\n    Returns:\n        An instance of this model.\n\n    Examples:\n        &gt;&gt;&gt; json_str = '{\"shape_type\": \"circle\", \"radius\": 5}'\n        &gt;&gt;&gt; circle = Circle.model_validate_json(json_str)\n    \"\"\"\n    # Parse JSON first\n    if isinstance(json_data, bytes):\n        json_data = json_data.decode()\n    data = json.loads(json_data)\n\n    # Now validate with our enhanced model_validate\n    return cls.model_validate(data, **kwargs)\n</code></pre>"},{"location":"reference/pydantic_discriminated/api/#pydantic_discriminated.api.DiscriminatedBaseModel.serialize_model","title":"<code>serialize_model()</code>","text":"<p>Custom serializer that includes discriminator fields only when requested.</p> <p>This method is used by Pydantic's serialization system to convert the model to a dictionary. It includes the discriminator fields, which can later be filtered out by model_dump if needed.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary representation of the model, including discriminator fields.</p> Source code in <code>src/pydantic_discriminated/api.py</code> <pre><code>@model_serializer\ndef serialize_model(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Custom serializer that includes discriminator fields only when requested.\n\n    This method is used by Pydantic's serialization system to convert the model\n    to a dictionary. It includes the discriminator fields, which can later be\n    filtered out by model_dump if needed.\n\n    Returns:\n        (dict): Dictionary representation of the model, including discriminator fields.\n    \"\"\"\n    # Get all field values without special handling\n    data = {k: v for k, v in self.__dict__.items() if not k.startswith(\"_\")}\n\n    # Add discriminator fields if configured to do so in global settings\n    # These will be filtered in model_dump if needed\n    if self._discriminator_field and self._discriminator_value is not None:\n        data[self._discriminator_field] = self._discriminator_value\n\n    # Add standard fields if configured\n    if self._use_standard_fields:\n        data[DiscriminatedConfig.standard_category_field] = self._discriminator_field\n        data[DiscriminatedConfig.standard_value_field] = self._discriminator_value\n\n    return data\n</code></pre>"},{"location":"reference/pydantic_discriminated/api/#pydantic_discriminated.api.DiscriminatedBaseModel.validate_discriminated","title":"<code>validate_discriminated(data)</code>  <code>classmethod</code>","text":"<p>Validate and return the appropriate discriminated model based on the discriminator value.</p> <p>This method looks at the discriminator fields in the data and dispatches to the appropriate model class based on the discriminator value.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict[str, Any]</code> <p>The data to validate.</p> required <p>Returns:</p> Type Description <code>DiscriminatedBaseModel</code> <p>An instance of the appropriate discriminated model.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no discriminator fields are found in the data.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; data = {\"shape_type\": \"circle\", \"radius\": 5}\n&gt;&gt;&gt; shape = DiscriminatedBaseModel.validate_discriminated(data)\n&gt;&gt;&gt; isinstance(shape, Circle)\nTrue\n</code></pre> Source code in <code>src/pydantic_discriminated/api.py</code> <pre><code>@classmethod\ndef validate_discriminated(cls, data: Dict[str, Any]) -&gt; \"DiscriminatedBaseModel\":\n    \"\"\"\n    Validate and return the appropriate discriminated model based on the discriminator value.\n\n    This method looks at the discriminator fields in the data and dispatches\n    to the appropriate model class based on the discriminator value.\n\n    Args:\n        data: The data to validate.\n\n    Returns:\n        An instance of the appropriate discriminated model.\n\n    Raises:\n        ValueError: If no discriminator fields are found in the data.\n\n    Examples:\n        &gt;&gt;&gt; data = {\"shape_type\": \"circle\", \"radius\": 5}\n        &gt;&gt;&gt; shape = DiscriminatedBaseModel.validate_discriminated(data)\n        &gt;&gt;&gt; isinstance(shape, Circle)\n        True\n    \"\"\"\n    use_standard_fields = getattr(\n        cls, \"_use_standard_fields\", DiscriminatedConfig.use_standard_fields\n    )\n\n    # First check standard discriminator fields if configured\n    if (\n        use_standard_fields\n        and DiscriminatedConfig.standard_category_field in data\n        and DiscriminatedConfig.standard_value_field in data\n    ):\n\n        category = data[DiscriminatedConfig.standard_category_field]\n        value = data[DiscriminatedConfig.standard_value_field]\n\n    # Fall back to domain-specific field\n    elif cls._discriminator_field and cls._discriminator_field in data:\n        category = cls._discriminator_field\n        value = data[cls._discriminator_field]\n    else:\n        raise ValueError(f\"No discriminator fields found in data\")\n\n    # Get the appropriate model class\n    model_cls = DiscriminatedModelRegistry.get_model(category, value)\n\n    # Validate with the model class\n    return model_cls.model_validate(data)\n</code></pre>"},{"location":"reference/pydantic_discriminated/api/#pydantic_discriminated.api.DiscriminatedConfig","title":"<code>DiscriminatedConfig</code>","text":"<p>Global configuration for discriminated models.</p> <p>This class contains settings that control how discriminated models behave, including whether to use standard fields, field naming, and monkey patching behavior.</p> <p>Attributes:</p> Name Type Description <code>use_standard_fields</code> <code>bool</code> <p>Whether to include standard discriminator fields in addition to domain-specific ones. Default is True.</p> <code>standard_category_field</code> <code>str</code> <p>The field name for the standard category field. Default is \"discriminator_category\".</p> <code>standard_value_field</code> <code>str</code> <p>The field name for the standard value field. Default is \"discriminator_value\".</p> <code>patch_base_model</code> <code>bool</code> <p>Flag to control whether to patch BaseModel. Default is True.</p> <code>_patched</code> <code>bool</code> <p>Internal flag to track if patching has been applied. Default is False.</p> Source code in <code>src/pydantic_discriminated/api.py</code> <pre><code>class DiscriminatedConfig:\n    \"\"\"\n    Global configuration for discriminated models.\n\n    This class contains settings that control how discriminated models behave,\n    including whether to use standard fields, field naming, and monkey patching behavior.\n\n    Attributes:\n        use_standard_fields (bool): Whether to include standard discriminator fields\n            in addition to domain-specific ones. Default is True.\n        standard_category_field (str): The field name for the standard category field.\n            Default is \"discriminator_category\".\n        standard_value_field (str): The field name for the standard value field.\n            Default is \"discriminator_value\".\n        patch_base_model (bool): Flag to control whether to patch BaseModel.\n            Default is True.\n        _patched (bool): Internal flag to track if patching has been applied.\n            Default is False.\n    \"\"\"\n\n    use_standard_fields: bool = True\n    standard_category_field: str = \"discriminator_category\"\n    standard_value_field: str = \"discriminator_value\"\n\n    # Flag to control whether to patch BaseModel\n    patch_base_model: bool = True\n\n    # Flag to track if patching has already been applied\n    _patched: bool = False\n\n    @classmethod\n    def enable_monkey_patching(cls):\n        \"\"\"\n        Enable monkey patching of BaseModel for discriminator support in all models.\n\n        This method enables the automatic inclusion of discriminator fields in\n        serialized output from any Pydantic model. It applies the patch if not\n        already applied.\n\n        Examples:\n            &gt;&gt;&gt; from pydantic_discriminated import DiscriminatedConfig\n            &gt;&gt;&gt; DiscriminatedConfig.enable_monkey_patching()\n        \"\"\"\n        cls.patch_base_model = True\n        # Apply the patch if not already applied\n        if not cls._patched:\n            _apply_monkey_patch()\n\n    @classmethod\n    def disable_monkey_patching(cls):\n        \"\"\"\n        Disable monkey patching of BaseModel.\n\n        When disabled, users must use DiscriminatorAwareBaseModel for containers\n        that need to preserve discriminator information in serialized output.\n        The flag is changed but the patch remains applied to avoid runtime changes\n        to method references.\n\n        Examples:\n            &gt;&gt;&gt; from pydantic_discriminated import DiscriminatedConfig\n            &gt;&gt;&gt; DiscriminatedConfig.disable_monkey_patching()\n        \"\"\"\n        print(\"DEBUG: Disabling monkey patching, previous value:\", cls.patch_base_model)\n        cls.patch_base_model = False\n        print(\"DEBUG: After disabling, new value:\", cls.patch_base_model)\n</code></pre>"},{"location":"reference/pydantic_discriminated/api/#pydantic_discriminated.api.DiscriminatedConfig.disable_monkey_patching","title":"<code>disable_monkey_patching()</code>  <code>classmethod</code>","text":"<p>Disable monkey patching of BaseModel.</p> <p>When disabled, users must use DiscriminatorAwareBaseModel for containers that need to preserve discriminator information in serialized output. The flag is changed but the patch remains applied to avoid runtime changes to method references.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pydantic_discriminated import DiscriminatedConfig\n&gt;&gt;&gt; DiscriminatedConfig.disable_monkey_patching()\n</code></pre> Source code in <code>src/pydantic_discriminated/api.py</code> <pre><code>@classmethod\ndef disable_monkey_patching(cls):\n    \"\"\"\n    Disable monkey patching of BaseModel.\n\n    When disabled, users must use DiscriminatorAwareBaseModel for containers\n    that need to preserve discriminator information in serialized output.\n    The flag is changed but the patch remains applied to avoid runtime changes\n    to method references.\n\n    Examples:\n        &gt;&gt;&gt; from pydantic_discriminated import DiscriminatedConfig\n        &gt;&gt;&gt; DiscriminatedConfig.disable_monkey_patching()\n    \"\"\"\n    print(\"DEBUG: Disabling monkey patching, previous value:\", cls.patch_base_model)\n    cls.patch_base_model = False\n    print(\"DEBUG: After disabling, new value:\", cls.patch_base_model)\n</code></pre>"},{"location":"reference/pydantic_discriminated/api/#pydantic_discriminated.api.DiscriminatedConfig.enable_monkey_patching","title":"<code>enable_monkey_patching()</code>  <code>classmethod</code>","text":"<p>Enable monkey patching of BaseModel for discriminator support in all models.</p> <p>This method enables the automatic inclusion of discriminator fields in serialized output from any Pydantic model. It applies the patch if not already applied.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pydantic_discriminated import DiscriminatedConfig\n&gt;&gt;&gt; DiscriminatedConfig.enable_monkey_patching()\n</code></pre> Source code in <code>src/pydantic_discriminated/api.py</code> <pre><code>@classmethod\ndef enable_monkey_patching(cls):\n    \"\"\"\n    Enable monkey patching of BaseModel for discriminator support in all models.\n\n    This method enables the automatic inclusion of discriminator fields in\n    serialized output from any Pydantic model. It applies the patch if not\n    already applied.\n\n    Examples:\n        &gt;&gt;&gt; from pydantic_discriminated import DiscriminatedConfig\n        &gt;&gt;&gt; DiscriminatedConfig.enable_monkey_patching()\n    \"\"\"\n    cls.patch_base_model = True\n    # Apply the patch if not already applied\n    if not cls._patched:\n        _apply_monkey_patch()\n</code></pre>"},{"location":"reference/pydantic_discriminated/api/#pydantic_discriminated.api.DiscriminatedModelRegistry","title":"<code>DiscriminatedModelRegistry</code>","text":"<p>Registry to store and retrieve discriminated models.</p> <p>This class maintains a registry of discriminated models indexed by their category and discriminator value, allowing lookup of the appropriate model class at validation time.</p> <p>Attributes:</p> Name Type Description <code>_registry</code> <code>Dict[str, Dict[Any, Type[DiscriminatedBaseModel]]]</code> <p>Internal registry storing models by category and discriminator value.</p> Source code in <code>src/pydantic_discriminated/api.py</code> <pre><code>class DiscriminatedModelRegistry:\n    \"\"\"\n    Registry to store and retrieve discriminated models.\n\n    This class maintains a registry of discriminated models indexed by their\n    category and discriminator value, allowing lookup of the appropriate model class\n    at validation time.\n\n    Attributes:\n        _registry (Dict[str, Dict[Any, Type[\"DiscriminatedBaseModel\"]]]): Internal registry\n            storing models by category and discriminator value.\n    \"\"\"\n\n    _registry: Dict[str, Dict[Any, Type[\"DiscriminatedBaseModel\"]]] = {}\n\n    @classmethod\n    def register(cls, category: str, value: Any, model_cls: Type[\"DiscriminatedBaseModel\"]) -&gt; None:\n        \"\"\"\n        Register a model class for a specific category and discriminator value.\n\n        Args:\n            category (str): The discriminator category (field name).\n            value (Any): The discriminator value.\n            model_cls : The model class to register.\n\n        Examples:\n            &gt;&gt;&gt; DiscriminatedModelRegistry.register(\"shape_type\", \"circle\", Circle)\n        \"\"\"\n        if category not in cls._registry:\n            cls._registry[category] = {}\n        cls._registry[category][value] = model_cls\n\n    @classmethod\n    def get_model(cls, category: str, value: Any) -&gt; Type[\"DiscriminatedBaseModel\"]:\n        \"\"\"\n        Get a model class by category and discriminator value.\n\n        Args:\n            category: The discriminator category (field name).\n            value: The discriminator value.\n\n        Returns:\n            Type[\"DiscriminatedBaseModel\"]: The model class registered for this category and value.\n\n        Raises:\n            ValueError: If no model is registered for the given category and value.\n\n        Examples:\n            &gt;&gt;&gt; model_cls = DiscriminatedModelRegistry.get_model(\"shape_type\", \"circle\")\n            &gt;&gt;&gt; instance = model_cls(radius=5)\n        \"\"\"\n        if category not in cls._registry:\n            raise ValueError(f\"No models registered for category '{category}'\")\n        if value not in cls._registry[category]:\n            raise ValueError(f\"No model found for value '{value}' in category '{category}'\")\n        return cls._registry[category][value]\n\n    @classmethod\n    def get_models_for_category(cls, category: str) -&gt; Dict[Any, Type[\"DiscriminatedBaseModel\"]]:\n        \"\"\"\n        Get all models registered for a specific category.\n\n        Args:\n            category: The discriminator category (field name).\n\n        Returns:\n            Dict[Any, Type[\"DiscriminatedBaseModel\"]]: Dictionary mapping discriminator values\n                to model classes for the specified category.\n\n        Raises:\n            ValueError: If no models are registered for the given category.\n\n        Examples:\n            &gt;&gt;&gt; models = DiscriminatedModelRegistry.get_models_for_category(\"shape_type\")\n            &gt;&gt;&gt; for value, model_cls in models.items():\n            ...     print(f\"{value}: {model_cls.__name__}\")\n        \"\"\"\n        if category not in cls._registry:\n            raise ValueError(f\"No models registered for category '{category}'\")\n        return cls._registry[category]\n</code></pre>"},{"location":"reference/pydantic_discriminated/api/#pydantic_discriminated.api.DiscriminatedModelRegistry.get_model","title":"<code>get_model(category, value)</code>  <code>classmethod</code>","text":"<p>Get a model class by category and discriminator value.</p> <p>Parameters:</p> Name Type Description Default <code>category</code> <code>str</code> <p>The discriminator category (field name).</p> required <code>value</code> <code>Any</code> <p>The discriminator value.</p> required <p>Returns:</p> Type Description <code>Type[DiscriminatedBaseModel]</code> <p>Type[\"DiscriminatedBaseModel\"]: The model class registered for this category and value.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no model is registered for the given category and value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; model_cls = DiscriminatedModelRegistry.get_model(\"shape_type\", \"circle\")\n&gt;&gt;&gt; instance = model_cls(radius=5)\n</code></pre> Source code in <code>src/pydantic_discriminated/api.py</code> <pre><code>@classmethod\ndef get_model(cls, category: str, value: Any) -&gt; Type[\"DiscriminatedBaseModel\"]:\n    \"\"\"\n    Get a model class by category and discriminator value.\n\n    Args:\n        category: The discriminator category (field name).\n        value: The discriminator value.\n\n    Returns:\n        Type[\"DiscriminatedBaseModel\"]: The model class registered for this category and value.\n\n    Raises:\n        ValueError: If no model is registered for the given category and value.\n\n    Examples:\n        &gt;&gt;&gt; model_cls = DiscriminatedModelRegistry.get_model(\"shape_type\", \"circle\")\n        &gt;&gt;&gt; instance = model_cls(radius=5)\n    \"\"\"\n    if category not in cls._registry:\n        raise ValueError(f\"No models registered for category '{category}'\")\n    if value not in cls._registry[category]:\n        raise ValueError(f\"No model found for value '{value}' in category '{category}'\")\n    return cls._registry[category][value]\n</code></pre>"},{"location":"reference/pydantic_discriminated/api/#pydantic_discriminated.api.DiscriminatedModelRegistry.get_models_for_category","title":"<code>get_models_for_category(category)</code>  <code>classmethod</code>","text":"<p>Get all models registered for a specific category.</p> <p>Parameters:</p> Name Type Description Default <code>category</code> <code>str</code> <p>The discriminator category (field name).</p> required <p>Returns:</p> Type Description <code>Dict[Any, Type[DiscriminatedBaseModel]]</code> <p>Dict[Any, Type[\"DiscriminatedBaseModel\"]]: Dictionary mapping discriminator values to model classes for the specified category.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no models are registered for the given category.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; models = DiscriminatedModelRegistry.get_models_for_category(\"shape_type\")\n&gt;&gt;&gt; for value, model_cls in models.items():\n...     print(f\"{value}: {model_cls.__name__}\")\n</code></pre> Source code in <code>src/pydantic_discriminated/api.py</code> <pre><code>@classmethod\ndef get_models_for_category(cls, category: str) -&gt; Dict[Any, Type[\"DiscriminatedBaseModel\"]]:\n    \"\"\"\n    Get all models registered for a specific category.\n\n    Args:\n        category: The discriminator category (field name).\n\n    Returns:\n        Dict[Any, Type[\"DiscriminatedBaseModel\"]]: Dictionary mapping discriminator values\n            to model classes for the specified category.\n\n    Raises:\n        ValueError: If no models are registered for the given category.\n\n    Examples:\n        &gt;&gt;&gt; models = DiscriminatedModelRegistry.get_models_for_category(\"shape_type\")\n        &gt;&gt;&gt; for value, model_cls in models.items():\n        ...     print(f\"{value}: {model_cls.__name__}\")\n    \"\"\"\n    if category not in cls._registry:\n        raise ValueError(f\"No models registered for category '{category}'\")\n    return cls._registry[category]\n</code></pre>"},{"location":"reference/pydantic_discriminated/api/#pydantic_discriminated.api.DiscriminatedModelRegistry.register","title":"<code>register(category, value, model_cls)</code>  <code>classmethod</code>","text":"<p>Register a model class for a specific category and discriminator value.</p> <p>Parameters:</p> Name Type Description Default <code>category</code> <code>str</code> <p>The discriminator category (field name).</p> required <code>value</code> <code>Any</code> <p>The discriminator value.</p> required <code>model_cls</code> <p>The model class to register.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; DiscriminatedModelRegistry.register(\"shape_type\", \"circle\", Circle)\n</code></pre> Source code in <code>src/pydantic_discriminated/api.py</code> <pre><code>@classmethod\ndef register(cls, category: str, value: Any, model_cls: Type[\"DiscriminatedBaseModel\"]) -&gt; None:\n    \"\"\"\n    Register a model class for a specific category and discriminator value.\n\n    Args:\n        category (str): The discriminator category (field name).\n        value (Any): The discriminator value.\n        model_cls : The model class to register.\n\n    Examples:\n        &gt;&gt;&gt; DiscriminatedModelRegistry.register(\"shape_type\", \"circle\", Circle)\n    \"\"\"\n    if category not in cls._registry:\n        cls._registry[category] = {}\n    cls._registry[category][value] = model_cls\n</code></pre>"},{"location":"reference/pydantic_discriminated/api/#pydantic_discriminated.api.DiscriminatorAwareBaseModel","title":"<code>DiscriminatorAwareBaseModel</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base model that handles discriminators in serialization, including nested models.</p> <p>Use this as a base class for container models when monkey patching is disabled. This class ensures that discriminator fields are properly included in serialized output even when the global monkey patching is disabled.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class Container(DiscriminatorAwareBaseModel):\n...     shape: Circle\n&gt;&gt;&gt; container = Container(shape=Circle(radius=5))\n&gt;&gt;&gt; data = container.model_dump()  # Will include discriminator fields\n</code></pre> Source code in <code>src/pydantic_discriminated/api.py</code> <pre><code>class DiscriminatorAwareBaseModel(BaseModel):\n    \"\"\"\n    Base model that handles discriminators in serialization, including nested models.\n\n    Use this as a base class for container models when monkey patching is disabled.\n    This class ensures that discriminator fields are properly included in serialized\n    output even when the global monkey patching is disabled.\n\n    Examples:\n        &gt;&gt;&gt; class Container(DiscriminatorAwareBaseModel):\n        ...     shape: Circle\n        &gt;&gt;&gt; container = Container(shape=Circle(radius=5))\n        &gt;&gt;&gt; data = container.model_dump()  # Will include discriminator fields\n    \"\"\"\n\n    def model_dump(self, **kwargs: Any) -&gt; Dict[str, Any]:\n        \"\"\"\n        Override model_dump to include discriminators at all nesting levels.\n\n        This method ensures that discriminator fields are included in the serialized\n        output regardless of the global monkey patching setting.\n\n        Args:\n            **kwargs: Keyword arguments to pass to the parent model_dump method.\n\n        Returns:\n            (dict): The serialized model with discriminator fields included.\n        \"\"\"\n        # Always use discriminators for this class by setting the flag\n        kwargs[\"use_discriminators\"] = True\n\n        # Get standard serialization with discriminators\n        if DiscriminatedConfig._patched:\n            # If BaseModel is patched, use the patched method with our flag\n            return super().model_dump(**kwargs)\n        else:\n            # If not patched, use the original method and process it ourselves\n            result = super().model_dump(**kwargs)\n            return _process_discriminators(self, result)\n\n    def model_dump_json(self, **kwargs: Any) -&gt; str:\n        \"\"\"\n        Override model_dump_json to include discriminators at all nesting levels.\n\n        This method ensures that discriminator fields are included in the JSON\n        serialized output regardless of the global monkey patching setting.\n\n        Args:\n            **kwargs: Keyword arguments to pass to the parent model_dump_json method.\n\n        Returns:\n            (str): The JSON string representation of the model with discriminator fields included.\n        \"\"\"\n        # Always use discriminators for this class\n        kwargs[\"use_discriminators\"] = True\n\n        # Get data with discriminators (will use our overridden model_dump)\n        if DiscriminatedConfig._patched:\n            # If patched, use the patched method with our flag\n            return super().model_dump_json(**kwargs)\n        else:\n            # If not patched, get data and convert to JSON ourselves\n            data = self.model_dump(**kwargs)\n            encoder = kwargs.pop(\"encoder\", None)\n            return json.dumps(data, default=encoder, **kwargs)\n</code></pre>"},{"location":"reference/pydantic_discriminated/api/#pydantic_discriminated.api.DiscriminatorAwareBaseModel.model_dump","title":"<code>model_dump(**kwargs)</code>","text":"<p>Override model_dump to include discriminators at all nesting levels.</p> <p>This method ensures that discriminator fields are included in the serialized output regardless of the global monkey patching setting.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Keyword arguments to pass to the parent model_dump method.</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict</code> <p>The serialized model with discriminator fields included.</p> Source code in <code>src/pydantic_discriminated/api.py</code> <pre><code>def model_dump(self, **kwargs: Any) -&gt; Dict[str, Any]:\n    \"\"\"\n    Override model_dump to include discriminators at all nesting levels.\n\n    This method ensures that discriminator fields are included in the serialized\n    output regardless of the global monkey patching setting.\n\n    Args:\n        **kwargs: Keyword arguments to pass to the parent model_dump method.\n\n    Returns:\n        (dict): The serialized model with discriminator fields included.\n    \"\"\"\n    # Always use discriminators for this class by setting the flag\n    kwargs[\"use_discriminators\"] = True\n\n    # Get standard serialization with discriminators\n    if DiscriminatedConfig._patched:\n        # If BaseModel is patched, use the patched method with our flag\n        return super().model_dump(**kwargs)\n    else:\n        # If not patched, use the original method and process it ourselves\n        result = super().model_dump(**kwargs)\n        return _process_discriminators(self, result)\n</code></pre>"},{"location":"reference/pydantic_discriminated/api/#pydantic_discriminated.api.DiscriminatorAwareBaseModel.model_dump_json","title":"<code>model_dump_json(**kwargs)</code>","text":"<p>Override model_dump_json to include discriminators at all nesting levels.</p> <p>This method ensures that discriminator fields are included in the JSON serialized output regardless of the global monkey patching setting.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Keyword arguments to pass to the parent model_dump_json method.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The JSON string representation of the model with discriminator fields included.</p> Source code in <code>src/pydantic_discriminated/api.py</code> <pre><code>def model_dump_json(self, **kwargs: Any) -&gt; str:\n    \"\"\"\n    Override model_dump_json to include discriminators at all nesting levels.\n\n    This method ensures that discriminator fields are included in the JSON\n    serialized output regardless of the global monkey patching setting.\n\n    Args:\n        **kwargs: Keyword arguments to pass to the parent model_dump_json method.\n\n    Returns:\n        (str): The JSON string representation of the model with discriminator fields included.\n    \"\"\"\n    # Always use discriminators for this class\n    kwargs[\"use_discriminators\"] = True\n\n    # Get data with discriminators (will use our overridden model_dump)\n    if DiscriminatedConfig._patched:\n        # If patched, use the patched method with our flag\n        return super().model_dump_json(**kwargs)\n    else:\n        # If not patched, get data and convert to JSON ourselves\n        data = self.model_dump(**kwargs)\n        encoder = kwargs.pop(\"encoder\", None)\n        return json.dumps(data, default=encoder, **kwargs)\n</code></pre>"},{"location":"reference/pydantic_discriminated/api/#pydantic_discriminated.api.discriminated_model","title":"<code>discriminated_model(category, discriminator, use_standard_fields=None)</code>","text":"<p>Decorator to create a discriminated model.</p> <p>This decorator registers a model class with the DiscriminatedModelRegistry and sets up the discriminator field and value.</p> <p>Parameters:</p> Name Type Description Default <code>category</code> <code>Union[str, Type[Enum]]</code> <p>The category field name or Enum class. If an Enum class is provided, its lowercase name is used as the field name.</p> required <code>discriminator</code> <code>Any</code> <p>The discriminator value for this model.</p> required <code>use_standard_fields</code> <code>Optional[bool]</code> <p>Whether to use standard discriminator fields. Defaults to the global setting in DiscriminatedConfig.</p> <code>None</code> <p>Returns:</p> Type Description <code>Callable[[Type[T]], Type[T]]</code> <p>A decorator function that registers the model class.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; @discriminated_model(\"shape_type\", \"circle\")\n... class Circle(DiscriminatedBaseModel):\n...     radius: float\n</code></pre> <pre><code>&gt;&gt;&gt; from enum import Enum\n&gt;&gt;&gt; class ShapeType(str, Enum):\n...     CIRCLE = \"circle\"\n...     RECTANGLE = \"rectangle\"\n&gt;&gt;&gt; @discriminated_model(ShapeType, ShapeType.CIRCLE)\n... class Circle(DiscriminatedBaseModel):\n...     radius: float\n</code></pre> Source code in <code>src/pydantic_discriminated/api.py</code> <pre><code>def discriminated_model(\n    category: Union[str, Type[Enum]],\n    discriminator: Any,\n    use_standard_fields: Optional[bool] = None,\n) -&gt; Callable[[Type[T]], Type[T]]:\n    \"\"\"\n    Decorator to create a discriminated model.\n\n    This decorator registers a model class with the DiscriminatedModelRegistry\n    and sets up the discriminator field and value.\n\n    Args:\n        category: The category field name or Enum class. If an Enum class is provided,\n            its lowercase name is used as the field name.\n        discriminator: The discriminator value for this model.\n        use_standard_fields: Whether to use standard discriminator fields.\n            Defaults to the global setting in DiscriminatedConfig.\n\n    Returns:\n        A decorator function that registers the model class.\n\n    Examples:\n        &gt;&gt;&gt; @discriminated_model(\"shape_type\", \"circle\")\n        ... class Circle(DiscriminatedBaseModel):\n        ...     radius: float\n\n        &gt;&gt;&gt; from enum import Enum\n        &gt;&gt;&gt; class ShapeType(str, Enum):\n        ...     CIRCLE = \"circle\"\n        ...     RECTANGLE = \"rectangle\"\n        &gt;&gt;&gt; @discriminated_model(ShapeType, ShapeType.CIRCLE)\n        ... class Circle(DiscriminatedBaseModel):\n        ...     radius: float\n    \"\"\"\n    category_field = category\n    if isinstance(category, type) and issubclass(category, Enum):\n        category_field = category.__name__.lower()\n\n    field_name = str(category_field)\n\n    def decorator(cls: Type[T]) -&gt; Type[T]:\n        \"\"\"\n        The actual decorator function that transforms the model class.\n\n        This inner function registers the model class with the DiscriminatedModelRegistry,\n        sets up discriminator attributes, and overrides __init__ to ensure discriminator\n        values are set correctly.\n\n        Args:\n            cls: The model class to decorate.\n\n        Returns:\n            The decorated model class.\n\n        Raises:\n            TypeError: If the class doesn't inherit from DiscriminatedBaseModel.\n        \"\"\"\n        # Make sure the class inherits from DiscriminatedBaseModel\n        if not issubclass(cls, DiscriminatedBaseModel):\n            raise TypeError(f\"{cls.__name__} must inherit from DiscriminatedBaseModel\")\n\n        # Register the model\n        DiscriminatedModelRegistry.register(field_name, discriminator, cls)\n\n        # Store the discriminator information as class variables\n        cls._discriminator_field = field_name\n        cls._discriminator_value = discriminator\n\n        # Set standard fields configuration\n        if use_standard_fields is not None:\n            cls._use_standard_fields = use_standard_fields\n        elif hasattr(cls, \"model_config\") and \"use_standard_fields\" in cls.model_config:\n            cls._use_standard_fields = cls.model_config[\"use_standard_fields\"]\n        else:\n            cls._use_standard_fields = DiscriminatedConfig.use_standard_fields\n\n        # Add the discriminator fields to the model's annotations\n        if not hasattr(cls, \"__annotations__\"):\n            cls.__annotations__ = {}\n\n        # Determine the type of the discriminator field\n        if isinstance(discriminator, Enum):\n            field_type = type(discriminator)\n        else:\n            field_type = type(discriminator)\n\n        # Add domain-specific field to annotations\n        cls.__annotations__[field_name] = field_type\n\n        # Add standard fields to annotations if configured\n        if cls._use_standard_fields:\n            cls.__annotations__[DiscriminatedConfig.standard_category_field] = str\n            cls.__annotations__[DiscriminatedConfig.standard_value_field] = field_type\n\n        # Update model_config to exclude discriminator fields by default\n        if not hasattr(cls, \"model_config\"):\n            cls.model_config = {}\n\n        # Get existing excluded fields or create an empty set\n        excluded = cls.model_config.get(\"excluded\", set())\n        if isinstance(excluded, list):\n            excluded = set(excluded)\n\n        # Add discriminator fields to excluded\n        excluded.add(field_name)\n        if cls._use_standard_fields:\n            excluded.add(DiscriminatedConfig.standard_category_field)\n            excluded.add(DiscriminatedConfig.standard_value_field)\n\n        cls.model_config[\"excluded\"] = excluded\n\n        # Override __init__ to set the discriminator values\n        original_init = cls.__init__\n\n        def init_with_discriminator(self, **data):\n            \"\"\"\n            Overridden __init__ that ensures discriminator values are set correctly.\n\n            This function adds the discriminator field and value to the initialization\n            data if missing, then calls the original __init__, and finally ensures\n            that discriminator attributes are set on the instance.\n\n            Args:\n                **data (dict[Any, Any]): Keyword arguments for initialization.\n            \"\"\"\n            # Add domain-specific discriminator field if missing\n            if field_name not in data:\n                data[field_name] = discriminator\n\n            # Add standard fields if configured\n            use_std_fields = cls._use_standard_fields\n            if use_std_fields:\n                if DiscriminatedConfig.standard_category_field not in data:\n                    data[DiscriminatedConfig.standard_category_field] = field_name\n                if DiscriminatedConfig.standard_value_field not in data:\n                    data[DiscriminatedConfig.standard_value_field] = discriminator\n\n            original_init(self, **data)\n\n            # Ensure discriminator values are set as instance attributes\n            object.__setattr__(self, field_name, discriminator)\n            object.__setattr__(self, \"_discriminator_field\", field_name)\n            object.__setattr__(self, \"_discriminator_value\", discriminator)\n            object.__setattr__(self, \"_use_standard_fields\", use_std_fields)\n\n            # Set standard fields if configured\n            if use_std_fields:\n                object.__setattr__(self, DiscriminatedConfig.standard_category_field, field_name)\n                object.__setattr__(self, DiscriminatedConfig.standard_value_field, discriminator)\n\n        cls.__init__ = init_with_discriminator\n\n        return cls\n\n    return decorator\n</code></pre>"}]}