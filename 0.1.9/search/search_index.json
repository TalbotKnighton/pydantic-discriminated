{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pydantic-discriminated","text":"<p>Type-safe discriminated unions for Pydantic models.</p> <p> </p>"},{"location":"#comparison-with-alternatives","title":"Comparison with Alternatives","text":""},{"location":"#why-pydantic-discriminated","title":"Why pydantic-discriminated?","text":"<p>While several libraries offer partial solutions to handling polymorphic data structures, pydantic-discriminated stands out by providing:</p> <ol> <li>True type safety that works with IDEs and static type checkers</li> <li>Seamless integration with Pydantic's ecosystem including FastAPI</li> <li>Flexible configuration with per-call control over serialization behavior</li> <li>Comprehensive support for nested models at any level</li> <li>Simple API with an intuitive decorator-based approach</li> </ol> <p>Most alternatives either lack proper type information, don't support nested structures, or require complex manual configuration. pydantic-discriminated solves these limitations with a clean, type-safe API that feels like a natural extension of Pydantic itself.</p>"},{"location":"#feature-comparison","title":"Feature Comparison","text":"Feature pydantic-discriminated pydantic TaggedUnion python-union pydantic-factories cattrs + attrs marshmallow + marshmallow-oneofschema Type Safety \u2705 Full type-checking support \u26a0\ufe0f Limited \u26a0\ufe0f Partial \u26a0\ufe0f Limited \u26a0\ufe0f Partial \u274c No Nested Models \u2705 Arbitrary nesting levels \u2705 Supported \u274c Limited \u274c No \u26a0\ufe0f Limited \u26a0\ufe0f Limited IDE Support \u2705 Full autocomplete \u26a0\ufe0f Partial \u26a0\ufe0f Partial \u26a0\ufe0f Partial \u26a0\ufe0f Partial \u274c No Runtime Control \u2705 Flexible configuration \u274c No \u274c No \u274c No \u26a0\ufe0f Limited \u26a0\ufe0f Limited OpenAPI Support \u2705 Complete \u2705 Basic \u26a0\ufe0f Manual setup \u274c No \u274c No \u26a0\ufe0f Partial Serialization Control \u2705 Per-call options \u274c No \u274c No \u274c No \u26a0\ufe0f Limited \u26a0\ufe0f Limited Standard Fields \u2705 Configurable \u274c No \u274c No \u274c No \u274c No \u274c No Validation \u2705 Full Pydantic validation \u2705 Full Pydantic validation \u26a0\ufe0f Basic \u26a0\ufe0f Limited \u2705 Supported \u2705 Supported Enum Support \u2705 Native Enum integration \u274c No \u274c No \u274c No \u26a0\ufe0f Manual \u26a0\ufe0f Manual Monkey Patching \u2705 Optional &amp; configurable \u274c No \u274c No \u274c No \u274c No \u274c No FastAPI Integration \u2705 Seamless \u26a0\ufe0f Basic \u26a0\ufe0f Manual setup \u274c No \u274c No \u26a0\ufe0f Limited Learning Curve \u2705 Simple decorator pattern \u26a0\ufe0f Moderate \u26a0\ufe0f Moderate \u26a0\ufe0f Steep \u26a0\ufe0f Steep \u26a0\ufe0f Steep Pydantic v2 Support \u2705 Full support \u2705 Supported \u274c Limited \u26a0\ufe0f Partial \u2753 Unknown \u2753 Unknown"},{"location":"#what-are-discriminated-unions","title":"What are Discriminated Unions?","text":"<p>Discriminated unions (also called tagged unions) let you work with polymorphic data in a type-safe way. A \"discriminator\" field tells you which concrete type you're dealing with.</p> <pre><code>from pydantic_discriminated import discriminated_model, DiscriminatedBaseModel\n\n@discriminated_model(\"shape_type\", \"circle\")\nclass Circle(DiscriminatedBaseModel):\n    radius: float\n\n    def area(self) -&gt; float:\n        return 3.14159 * self.radius ** 2\n\n@discriminated_model(\"shape_type\", \"rectangle\")\nclass Rectangle(DiscriminatedBaseModel):\n    width: float\n    height: float\n\n    def area(self) -&gt; float:\n        return self.width * self.height\n\n# Parse data with the correct type\ndata = {\"shape_type\": \"circle\", \"radius\": 5}\ncircle = Circle.model_validate(data)  # Fully typed as Circle\nprint(f\"Area: {circle.area()}\")  # 78.53975\n</code></pre>"},{"location":"#features","title":"Features","text":"<ul> <li>\ud83d\udd0d Type Safety: Proper type hints for IDE autocomplete and static analysis</li> <li>\ud83d\udce6 Nested Models: Works with models nested at any level</li> <li>\ud83d\udd04 Seamless Integration: Uses standard Pydantic methods (<code>model_validate</code>, <code>model_dump</code>)</li> <li>\ud83e\udde9 Polymorphic Validation: Automatically validates and dispatches to the correct model type</li> <li>\ud83d\udcda OpenAPI Compatible: Works great with FastAPI for generating correct schemas</li> <li>\ud83d\udd27 Flexible Serialization: Control how and when discriminator fields appear in output</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install pydantic-discriminated\n</code></pre>"},{"location":"#how-it-works","title":"How It Works","text":"<p>pydantic-discriminated uses a combination of techniques to provide powerful discriminated union functionality:</p> <ol> <li>Decorator-based Registration: Models are registered with their discriminator field and value</li> <li>Enhanced Serialization: Controls when discriminator fields appear in serialized output</li> <li>Type Preservation: Maintains proper typing for IDE support and static analysis</li> <li>Flexible Configuration: Offers both global and per-model configuration options</li> </ol>"},{"location":"#two-serialization-approaches","title":"Two Serialization Approaches","text":""},{"location":"#1-automatic-simple","title":"1. Automatic (Simple)","text":"<p>With monkey patching enabled (the default), discriminator fields are automatically included:</p> <pre><code>from pydantic import BaseModel\nfrom pydantic_discriminated import discriminated_model, DiscriminatedBaseModel\n\n@discriminated_model(\"shape_type\", \"circle\")\nclass Circle(DiscriminatedBaseModel):\n    radius: float\n\n# Regular BaseModel works automatically\nclass Container(BaseModel):\n    my_shape: Circle\n\ncontainer = Container(my_shape=Circle(radius=5))\ndata = container.model_dump()\n# Includes shape_type automatically:\n# {\"my_shape\": {\"radius\": 5, \"shape_type\": \"circle\", ...}}\n</code></pre>"},{"location":"#2-explicit-advanced","title":"2. Explicit (Advanced)","text":"<p>For more control, you can disable monkey patching and use <code>DiscriminatorAwareBaseModel</code>:</p> <pre><code>from pydantic_discriminated import (\n    discriminated_model, DiscriminatedBaseModel,\n    DiscriminatorAwareBaseModel, DiscriminatedConfig\n)\n\n# Disable automatic patching\nDiscriminatedConfig.disable_monkey_patching()\n\n@discriminated_model(\"shape_type\", \"circle\")\nclass Circle(DiscriminatedBaseModel):\n    radius: float\n\n# Use the aware base model for containers\nclass Container(DiscriminatorAwareBaseModel):\n    my_shape: Circle\n\ncontainer = Container(my_shape=Circle(radius=5))\ndata = container.model_dump()\n# Still includes shape_type:\n# {\"my_shape\": {\"radius\": 5, \"shape_type\": \"circle\", ...}}\n</code></pre>"},{"location":"#quick-example","title":"Quick Example","text":"<p>Define discriminated models for different event types:</p> <pre><code>from enum import Enum\nfrom typing import List, Union\nfrom pydantic import BaseModel\nfrom pydantic_discriminated import discriminated_model, DiscriminatedBaseModel\n\nclass EventType(str, Enum):\n    USER_CREATED = \"user_created\"\n    USER_UPDATED = \"user_updated\"\n    LOGIN_ATTEMPT = \"login_attempt\"\n\n@discriminated_model(EventType, EventType.USER_CREATED)\nclass UserCreatedEvent(DiscriminatedBaseModel):\n    user_id: str\n    username: str\n\n@discriminated_model(EventType, EventType.USER_UPDATED)\nclass UserUpdatedEvent(DiscriminatedBaseModel):\n    user_id: str\n    fields_changed: List[str]\n\n@discriminated_model(EventType, EventType.LOGIN_ATTEMPT)\nclass LoginAttemptEvent(DiscriminatedBaseModel):\n    user_id: str\n    success: bool\n    ip_address: str\n\n# Container that handles any event type\nclass EventProcessor(BaseModel):\n    events: List[Union[UserCreatedEvent, UserUpdatedEvent, LoginAttemptEvent]]\n\n    def process(self):\n        for event in self.events:\n            if isinstance(event, UserCreatedEvent):\n                print(f\"New user created: {event.username}\")\n            elif isinstance(event, UserUpdatedEvent):\n                print(f\"User {event.user_id} updated fields: {event.fields_changed}\")\n            elif isinstance(event, LoginAttemptEvent):\n                result = \"succeeded\" if event.success else \"failed\"\n                print(f\"Login {result} for user {event.user_id} from {event.ip_address}\")\n</code></pre>"},{"location":"#fine-grained-control","title":"Fine-Grained Control","text":"<p>You can control discriminator field inclusion on a per-call basis:</p> <pre><code># Always include discriminator fields (with monkey patching enabled)\ndata = shape.model_dump()\n\n# Explicitly control discriminator inclusion\nwith_disc = shape.model_dump(use_discriminators=True)\nwithout_disc = shape.model_dump(use_discriminators=False)\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Full Documentation</li> <li>API Reference</li> <li>Examples</li> </ul>"},{"location":"#when-to-use","title":"When To Use","text":"<p>This library is perfect for:</p> <ul> <li>API Responses: When endpoints return different object types</li> <li>Event Systems: Handling different event types in a type-safe way</li> <li>State Machines: Representing different states with specific properties</li> <li>Polymorphic Data: Working with heterogeneous data structures</li> </ul>"},{"location":"#resources","title":"Resources","text":"<ul> <li>GitHub Repository</li> <li>PyPI Package</li> <li>Issue Tracker</li> </ul>"},{"location":"#license","title":"License","text":"<p>MIT</p> <p>Built by Talbot Knighton</p>"},{"location":"technical_documentation/","title":"Technical Implementation","text":"<p>This page explains the technical details of how pydantic-discriminated works under the hood.</p>"},{"location":"technical_documentation/#architecture-overview","title":"Architecture Overview","text":"<p>pydantic-discriminated consists of several key components:</p> <ol> <li>DiscriminatedBaseModel: Base class for all discriminated models</li> <li>DiscriminatorAwareBaseModel: Base class for containers that need to handle discriminated models</li> <li>DiscriminatedModelRegistry: Central registry of discriminated models and their values</li> <li>DiscriminatedConfig: Global configuration settings</li> <li>Monkey Patching System: Optional enhancement to Pydantic's BaseModel for automatic discriminator handling</li> </ol>"},{"location":"technical_documentation/#discriminator-registration","title":"Discriminator Registration","text":"<p>The <code>@discriminated_model</code> decorator performs several important tasks:</p> <ol> <li>Registers the model class in the <code>DiscriminatedModelRegistry</code> with its category and value</li> <li>Sets class-level attributes (<code>_discriminator_field</code>, <code>_discriminator_value</code>) to store discriminator information</li> <li>Adds the discriminator field to the model's annotations</li> <li>Overrides <code>__init__</code> to ensure discriminator values are set on the instance</li> </ol> <pre><code>@discriminated_model(\"animal_type\", \"dog\")\nclass Dog(DiscriminatedBaseModel):\n    name: str\n    breed: str\n</code></pre> <p>This registration enables: - Type-safe validation (ensuring the discriminator field has the correct value) - Runtime access to discriminator information - Proper serialization of discriminator fields</p>"},{"location":"technical_documentation/#serialization-strategies","title":"Serialization Strategies","text":""},{"location":"technical_documentation/#1-monkey-patching-approach","title":"1. Monkey Patching Approach","text":"<p>When enabled, this approach patches Pydantic's <code>BaseModel.model_dump</code> and <code>BaseModel.model_dump_json</code> methods to automatically process discriminator fields in nested models.</p> <p>The patching process: 1. Stores the original methods in <code>_original_methods</code> 2. Defines patched versions that check the <code>use_discriminators</code> parameter or global setting 3. Processes nested models to add discriminator fields when appropriate</p> <p>This approach allows regular <code>BaseModel</code> containers to automatically handle discriminated models.</p>"},{"location":"technical_documentation/#2-explicit-base-class-approach","title":"2. Explicit Base Class Approach","text":"<p>For more control or when monkey patching is disabled, <code>DiscriminatorAwareBaseModel</code> provides explicit handling of discriminated fields:</p> <ul> <li>Overrides <code>model_dump</code> and <code>model_dump_json</code> to always process discriminators</li> <li>Recursively processes nested models to ensure consistent behavior</li> <li>Not affected by the global monkey patching setting</li> </ul>"},{"location":"technical_documentation/#discriminator-processing","title":"Discriminator Processing","text":"<p>The <code>_process_discriminators</code> function is responsible for:</p> <ol> <li>Recursively traversing the serialized data structure</li> <li>Identifying discriminated models at any nesting level</li> <li>Adding or removing discriminator fields based on configuration</li> <li>Handling lists of models, individual models, and regular fields appropriately</li> </ol>"},{"location":"technical_documentation/#standard-fields","title":"Standard Fields","text":"<p>For interoperability with different systems, pydantic-discriminated supports standard discriminator fields:</p> <ul> <li>Domain-specific field: The field name used in your domain model (e.g., <code>\"shape_type\"</code>)</li> <li>Standard category field: Always <code>\"discriminator_category\"</code>, stores the field name</li> <li>Standard value field: Always <code>\"discriminator_value\"</code>, stores the discriminator value</li> </ul> <p>This allows other systems to identify and process discriminated models without prior knowledge of your domain-specific fields.</p>"},{"location":"technical_documentation/#configuration-options","title":"Configuration Options","text":"<p>The <code>DiscriminatedConfig</code> class provides global settings:</p> <ul> <li>use_standard_fields: Whether to include standard discriminator fields</li> <li>standard_category_field: Name of the standard category field</li> <li>standard_value_field: Name of the standard value field</li> <li>patch_base_model: Whether to apply monkey patching to BaseModel</li> </ul> <p>These can be overridden: 1. Globally via <code>DiscriminatedConfig</code> 2. Per-model via <code>model_config</code> 3. Per-decorator via parameters 4. Per-call via <code>use_discriminators</code> parameter</p>"},{"location":"technical_documentation/#performance-considerations","title":"Performance Considerations","text":"<p>The library is designed for efficiency:</p> <ul> <li>Registry lookups are O(1)</li> <li>Serialization processing adds minimal overhead</li> <li>Type information is preserved without runtime cost</li> <li>Monkey patching is applied only once regardless of imports</li> </ul>"},{"location":"technical_documentation/#implementation-challenges","title":"Implementation Challenges","text":"<p>Some interesting challenges addressed in the implementation:</p> <ol> <li>Preserving Type Safety: Ensuring IDEs and type checkers understand discriminated unions</li> <li>Recursive Processing: Handling models nested at arbitrary depths</li> <li>Configuration Flexibility: Balancing global settings with per-model and per-call options</li> <li>Monkey Patching Control: Providing both automatic and explicit approaches</li> <li>Discriminator Validation: Ensuring discriminator values match at validation time</li> </ol>"},{"location":"technical_documentation/#extending-the-library","title":"Extending the Library","text":"<p>To extend the library, you can:</p> <ol> <li>Create custom base classes that inherit from <code>DiscriminatedBaseModel</code></li> <li>Add middleware to process discriminator fields in specific ways</li> <li>Implement custom serializers for special discriminator handling</li> <li>Extend <code>DiscriminatedConfig</code> with additional settings</li> </ol>"},{"location":"technical_documentation/#integration-with-other-libraries","title":"Integration with Other Libraries","text":"<p>pydantic-discriminated is designed to work seamlessly with:</p> <ul> <li>FastAPI: For generating correct OpenAPI schemas with discriminators</li> <li>SQLModel: For ORM models that need discriminator functionality</li> <li>Type checkers: mypy, pyright, etc.</li> <li>API clients: For properly serializing discriminated models in requests</li> </ul>"}]}