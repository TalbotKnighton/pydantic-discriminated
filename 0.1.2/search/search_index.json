{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pydantic-discriminated","text":"<p>A robust, type-safe implementation of discriminated unions for Pydantic models.</p> <p> </p>"},{"location":"#what-are-discriminated-unions","title":"What are Discriminated Unions?","text":"<p>Discriminated unions (also called tagged unions) let you work with polymorphic data in a type-safe way. A \"discriminator\" field tells you which concrete type you're dealing with.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install pydantic-discriminated\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>from enum import Enum\nfrom typing import List, Union\nfrom pydantic import BaseModel\n\nfrom pydantic_discriminated import discriminated_model, DiscriminatedBaseModel\n\n# Define discriminated models with their tag values\n@discriminated_model(\"shape_type\", \"circle\")\nclass Circle(DiscriminatedBaseModel):\n    radius: float\n\n    def area(self) -&gt; float:\n        return 3.14159 * self.radius ** 2\n\n@discriminated_model(\"shape_type\", \"rectangle\")\nclass Rectangle(DiscriminatedBaseModel):\n    width: float\n    height: float\n\n    def area(self) -&gt; float:\n        return self.width * self.height\n\n# Container for shapes\nclass ShapeCollection(BaseModel):\n    shapes: List[Union[Circle, Rectangle]]\n\n    def total_area(self) -&gt; float:\n        return sum(shape.area() for shape in self.shapes)\n\n# Parse polymorphic data correctly\ndata = {\n    \"shapes\": [\n        {\"shape_type\": \"circle\", \"radius\": 5},\n        {\"shape_type\": \"rectangle\", \"width\": 10, \"height\": 20}\n    ]\n}\n\nshapes = ShapeCollection.model_validate(data)\nprint(f\"Total area: {shapes.total_area()}\")  # 278.5795\n\n# Each shape is properly typed\nfor shape in shapes.shapes:\n    if isinstance(shape, Circle):\n        print(f\"Circle with radius {shape.radius}\")\n    elif isinstance(shape, Rectangle):\n        print(f\"Rectangle with dimensions {shape.width}x{shape.height}\")\n</code></pre>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>\ud83d\udd0d Type Safety: Proper type hints for IDE autocomplete and static analysis</li> <li>\ud83d\udce6 Nested Models: Works with models nested at any level</li> <li>\ud83d\udd04 Seamless Integration: Uses standard Pydantic methods (<code>model_validate</code>, <code>model_dump</code>)</li> <li>\ud83e\udde9 Polymorphic Validation: Automatically validates and dispatches to the correct model type</li> <li>\ud83d\udcda OpenAPI Compatible: Works great with FastAPI for generating correct schemas</li> </ul>"},{"location":"#why-use-this","title":"Why Use This?","text":"<p>If you've ever needed to handle polymorphic data structures (like different event types, various message formats, or heterogeneous API responses), you'll appreciate how this library makes it clean and type-safe.</p>"},{"location":"#common-use-cases","title":"Common Use Cases","text":"<ul> <li>API Responses: When an endpoint can return different object types</li> <li>Event Processing: Handle different event types in a type-safe way</li> <li>State Machines: Model different states with specific properties</li> <li>Data Schemas: Define polymorphic data models with validation</li> </ul>"},{"location":"#how-it-works","title":"How It Works","text":"<ol> <li>The <code>@discriminated_model</code> decorator registers models with their discriminator field and value</li> <li>When parsing data, the discriminator value determines which model class to use</li> <li>Type information is preserved, so IDEs and type checkers understand the specific model type</li> <li>Serialization automatically includes the discriminator field</li> </ol>"},{"location":"#advanced-usage","title":"Advanced Usage","text":""},{"location":"#enum-discriminators","title":"Enum Discriminators","text":"<pre><code>from enum import Enum\n\nclass MessageType(str, Enum):\n    TEXT = \"text\"\n    IMAGE = \"image\"\n    VIDEO = \"video\"\n\n@discriminated_model(MessageType, MessageType.TEXT)\nclass TextMessage(DiscriminatedBaseModel):\n    content: str\n\n@discriminated_model(MessageType, MessageType.IMAGE)\nclass ImageMessage(DiscriminatedBaseModel):\n    url: str\n    width: int\n    height: int\n</code></pre>"},{"location":"#dynamic-model-selection","title":"Dynamic Model Selection","text":"<pre><code># Validate data into the appropriate model based on discriminator\nmessage_data = {\"messagetype\": \"text\", \"content\": \"Hello world\"}\nmessage = TextMessage.validate_discriminated(message_data)\n\n# Type checker doesn't know the exact type, so cast when needed\nif isinstance(message, TextMessage):\n    print(f\"Text message: {message.content}\")\n</code></pre>"},{"location":"#configuration-options","title":"Configuration Options","text":"<pre><code>from pydantic_discriminated import DiscriminatedConfig\n\n# Global configuration\nDiscriminatedConfig.use_standard_fields = False\n\n# Per-model configuration using model_config\n@discriminated_model(\"animal_type\", \"cat\")\nclass Cat(DiscriminatedBaseModel):\n    model_config = {\"use_standard_fields\": False}\n    name: str\n    lives_left: int\n\n# Direct parameter in decorator\n@discriminated_model(\"animal_type\", \"dog\", use_standard_fields=True)\nclass Dog(DiscriminatedBaseModel):\n    name: str\n    breed: str\n</code></pre>"},{"location":"#fastapi-example","title":"FastAPI Example","text":"<pre><code>from fastapi import FastAPI, HTTPException\nfrom typing import Union, List\n\napp = FastAPI()\n\n@app.post(\"/shapes/\")\ndef process_shape(shape: Union[Circle, Rectangle]):\n    return {\"area\": shape.area()}\n\n@app.post(\"/shape-collection/\")\ndef process_shapes(shapes: ShapeCollection):\n    return {\"total_area\": shapes.total_area()}\n</code></pre> <p>This will automatically generate the correct OpenAPI schema with discriminator support!</p>"},{"location":"#comparison-with-alternatives","title":"Comparison with Alternatives","text":"Feature pydantic-discriminated python-union pydantic-factories Type safety \u2705 Full \u26a0\ufe0f Partial \u26a0\ufe0f Limited Nested models \u2705 Yes \u274c No \u274c No IDE support \u2705 Full \u26a0\ufe0f Partial \u26a0\ufe0f Partial OpenAPI integration \u2705 Yes \u26a0\ufe0f Partial \u274c No Configuration options \u2705 Yes \u274c No \u274c No"},{"location":"#learn-more","title":"Learn More","text":"<ul> <li>Discriminated Unions in TypeScript</li> <li>Algebraic Data Types</li> <li>OpenAPI Discriminator Object</li> </ul>"},{"location":"#license","title":"License","text":"<p>MIT</p> <p>This library fills a significant gap in Pydantic's functionality. If you work with polymorphic data structures, it will make your life easier!</p>"}]}